### IT 기술면접 공부하기

---

2. ### DB

	* **Connection Pool**

		* 미리 connect한 객체들을 생성해서 pool에 저장했다가 요청이 오면 이를 사용
		* 장점
			* 매 연결마다 객체를 생성/제거 하는 비용 감소
			* 미리 생성된 객체를 사용하므로 접근 시간 단축
			* Connection 수를 제한해 부하 조정
		* 단점
			* Connection 또한 객체이므로 메모리 차지
			* Connection 개수를 잘 못 설정할 경우 쓸모없는 Connection이 발생할 수 있음
		* 부족한 경우
			* 모든 Connection이 처리중일 때 대기 상태로 전환
			* 반환되면 순차적으로 요청을 처리
		* **Thead Pool 과 Connection Pool**
			* **WAS에서 Thread Pool과 Connection Pool의 Thread와 Connection의 수는 메모리에 직접적으로 관련이 있음**
			* 많이 설정하면 메모리 잡아 먹고
			* 적게하면 처리 못하고 대기하게 된다.

	* **트랜잭션**

		* **트랜잭션이란** 
			* 데이터베이스의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합이다.
		* **하나의 트랜잭션은 Commit 되거나 Rollback 된다.**
			* Commit 연산
				* 한개의 논리적 단위에 대한 작업이 성공적으로 끝나 DB가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.
			* Rollback 연산
				* 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현학 위해 이 트랜잭션이 행한 모든 연산을 **UNDO** 하는 연산이다
				* 해당 트랜잭션을 재시작 or 폐기한다.
			* **DB 응용 프로그램은 트랜잭션들의 집합으로 정의 할 수 있다.**
		* **트랜잭션의 성질 ACID**
			* **Atomicity - All or Nothing**
				* 트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태로 보장해야 한다.
			* **Consistency**
				* 트랜잭션 완료 후에도 DB가 일관된 상태로 유지되어야 한다.
			* **Isolation**
				* 하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못한다.
			* **Durability**
				* 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.
		* **트랜잭션의 상태**
			* ![img](https://gmlwjd9405.github.io/images/basic-concepts-of-development/transaction-status.png)
			* Active
				* 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태
			* Failed
				* 트랜잭션이 실행에 오류가 발생하여 중단된 상태
			* Aborted
				* 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
			* Partially Committed
				* 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
			* Committed
				* 트랜잭션이 성공적으로 종료되어 Commit 연산을 수행한 후의 상태

	* **동시성 제어**

		* 필요성
			* 다중 DBMS 상황에 한 트랜잭션이 실행하는 중에 다른 트랜잭션이 끼어들어 실행할 수 있다.
			* 동시에 실행되는 다른 트랜잭션 서로 간에 간섭함으로써 갱신 분실, 연쇄 복귀 또는 회복 불가능, 불일치 분석 등 문제 야기
		* 해결법
			* **Locking 기법**
				* 하나의 트랜잭션이 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 **상호배제** 기능을 제공하는 기법이다.
				* **독점적으로 사용할 수 있도록 한다**
			* **잠금 연산의 종류**
				* S-lock (공유잠금)
					* **읽기 연산만 가능하다**
					* 하나의 데이터 항목에 대해 여러 개의 공유 잠금이 가능하다.
					* **다른 트랜잭션도 읽기는 가능하다**
				* X-lock (베타잠금)
					* 배타잠금을 설정한 트랜잭션은 읽기와 쓰기 모두 가능하다.
					* 하나의 데이터 항목은 하나의 베타잠금만 가능하다
					* 다른 애들은 읽기도 쓰기도 못함
			* **잠금의 한계**
				* **직렬 가능한 스케줄이 항상 보장되지 않는다.**
				* **교착상태가 발생할 수 있다.**
			* **해결법**
				* **2단계 잠금 규약**
					* 2PL은 잠금을 설정하는 단계와 해제하는 단계로 나누어 수행한다.
					* **확장단계**
						* 트랜잭션이 lock 연산만 수행할 수 있고 unlock 연산은 수행할 수 없느 단계
					* **축소단계**
						* 트랜잭션이 unlock 연산만 수행할 수 있고 lock 연산은 수행할 수 없는 단계
					* 허나 이래도 **교착상태 문제는 여전히 해결되지 않는다.**
				* **엄격한 2단계 잠금 규약**
					* 모든 X-lock에 대한 unlock 연산을 트랜잭션이 완전히 완료된 후에 실행하는 것이다.

	* **JOIN**

		* 복수의 테이블을 결합, 하나의 테이블인 것처럼 결과를 출력
			* INNER JOIN : 조인하는 두개의 테이블 모두에 데이터가 존재하는 행에 대해서만 결과를 가져온다.
			* OUTER JOIN : 매칭되는 행이 없어도 결과를 가져오고 매칭되는 행이 없는 경우 NULL로 표시한다.

	* **SQL Injection**

		* SQL Injection 이란 악의적인 사용자가 보안상의 취약점을 이용하여, 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위 입니다. 인젝션 공격은 OWASP Top10 중 첫 번째에 속해 있으며, 공격이 비교적 쉬운 편이고 공격에 성공할 경우 큰 피해를 입힐 수 있는 공격입니다.

	* **Index**

		* 인덱스란

			* RDMS에서 검색 속도를 높이기 위한 기술
			* TABLE의 컬럼을 색인화하여 검색시 해당 TABLE의 레코드를 Full Scan 하는게 아니라 색인화 되어있는 INDEX 파일을 검색하여 검색속도를 빠르게 한다.
			* DELETE, INSERT, UPDATE 쿼리에는 해당 사항이없으며 INDEX 사용시 오히려 느려진다
			* **즉 인덱스는 데이터를 SELECT 할 때 빨리 찾기 위해 사용**된다.

		* **사용 이유**

			* **where 구문과 일치하는 열을 빨리 찾기 위해**
			* 특정 열을 고려 대상에서 빨리 없애기 위해
			* **조인 실행할 때 다른 테이블에서 열을 추출하기 위해**
			* 특정하게 인덱스된 컬럼을 위한 **MIN(), MAX()값을 찾기 위해**
			* 정렬 및 그룹화 하기 위해
			* 쿼리를 최적화 하기 위해

		* **구조와 작동 원리**

			* 구조

				* **논리적/물리적으로 테이블과 독립적이다**
				* 테이블은 데이터가 정렬되지 않고 입력된 순서대로 들어가지만 INDEX는 KEY컬럼과 ROWID 컬럼 두개로 이루어져 있고 오름차순, 내림차순으로 정렬이 가능하다

			* **작동 원리**

				```sql
				select * from emp where empno = 7902;
				```

				* 데이터 파일이 10만개 일경우
					1. 서버 프로세스가 파싱 과정을 마친 후 `DB buffer cache`에 empno가 7902인 정보가 있는지 확인
					2. 정보가 없으면 하드 디스크 파일에서 7902정보를 가진 블록을 복사해 가져온 뒤 7900정보만 골라내서 사용자에게 보여줌
					3. **Index가 없는 경우**
						* 7902정보가 어떤 블록에 들어 있는지 모르므로 10만개 전부 복사한 뒤 하나하나 찾는다.
					4. **Index가 있는 경우**
						* where절의 컬럼이 index가 만들어져 있는지 확인
						* 인덱스에 먼저 가서 7902정보가 어떤 `ROWID`를 가지고 있는지 확인
						* 해당 블록만 복사

			* **DML 발생시**

				1. INSER
					* 기존의 block에 여유가 없을 때 data가 입력되면
					* 새로운 block을 할당 받은 후 key를 옮기는 작업 수행
					* index split 작업 동안, 해당 block의 key값에 대해서 DML이 블로킹 된다.
					* 대기 이벤트 발생
				2. DELETE
					* **Table에서 지워지는경우**
						* Data가 지워지고 다른 Data가 그 공간을 사용 가능
					* **Index에서 Data가 지워지는 경우**
						* Data가 지워지지 않고, 사용 안됨 표시만 해둔다.
						* **Table의 Data 수와 Index의 Data수가 다를 수 있다. **
				3. UPDATE
					* table update -> index는 update 불가능
					* index에서는 delete 후 insert 작업으로 -> 2배의 작업이 소요된다.

			* **종류**

				* **Clustered 인덱스**
					* 물리적 정렬로 DB 데이터를 입력시 Clustered 인덱스를 기준으로 입력이 된다.
					* 따라서 한 테이블에 오직 하나만 존재하며 order by 사용하지 않아도 정렬이 되어있다.
				* **NonClustered 인덱스**
					* 중복된 값을 가지면 한 테이블에 여러 개를 생성할 수 있다.
				* **Clustered 되어있을 때, Index Scan이 유리하다**

			* **장단점**

				* 장점
					* **키 값을 기초로** 하여 테이블에서 **검색과 정렬 속도를 향상**시킨다.
					* 질의나 보고서에서 그룹화 **작업의 속도를 향상**시킨다.
					* 인덱스를 사용하면 **테이블 행의 고유성을 강화**시킬 수 있다.
					* **테이블의 기본 키는 자동으로 인덱스**가 된다.
				* 단점
					* Index 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 떨어진다.
					* 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로 성능에 영향을 미친다.
					* Index를 생성하는데 시간이 많이 소요될 수 있다.
					* Index가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다.

			* **Index를 남발하지 말아야 하는 이유**

				* 성능문제 발생시 무분별하게 index 생성시
				* 문제를 야기한 쿼리문을 빠르게 만들 순 있지만 **전체적인 DB의 성능 부하를 초래하게 된다.**
				* **SQL문을 좀 더 효율적으로 짜는 방향으로 나가야 한다.**
				* 인덱스 생성은 마지막 수단?

			* **명시 사항**

				* where절에서 자주 사용하는 컬럼에 사용
				* order by에 항상 또는 자주 사용되는 컬럼에 사용
				* join으로 자주 사용되는 컬럼에 사용
				* **DML이 많은 컬럼은 걸지 않는다.**

			* **리빌드**

				* 인덱스 파일은 생성 후 **Insert, Update, Delete등을 반복하다보면 성능이 저하**된다.
				* 생성된 **인덱스는 트리구조**를 가지는데, 삽입,수정,삭제등이 오랫동안 일어나다보면 **트리의 한쪽이 무거워져 전체적으로 트리의 깊이가 깊어지기 때문**이다.
				* 이러한 현상으로 인해 **인덱스의 검색속도가 떨어지므로 주기적으로 리빌딩하는 작업을 거치는것이 좋다.**

	* **DB Partitioning**

		* 배경
			* 데이터의 대용량화로 기존의 DB 시스템의 용량의 한계와 성능의 저하를 가져오게 됨
			* 성능 측면에 많은 이슈를 해결하기 위해 **table을 파티션이라는 작은 단위로 나누어 관리하는 파티셔닝 기법**이 나타나게 되었다.
		* 개념
			* 논리적인 데이터 element를 다수의 entity로 쪼개는 행위
		* 특징
			* 성능
				* DML과 쿼리 성능 향상
				* 주로 대용량에서 효율적
				* Full Scan의 범위를 줄여줌
			* 가용성
				* 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.
				* 각 분할 영역을 독립적으로 백업하고 복구 가능
			* 관리가 쉽다.
		* 장단점
			* 장점
				* CRUD
				* 전체 데이터 손실할 가능성을 줄여준다.
				* 백업 및 복구 능력
			* 단점
				* table간의 join 비용증가
				* table과 index를 별도로 파티셔닝 할 수 없다.