### 정보처리기사

---

1. __소프트웨어 개발__
	4. __애플리케이션 테스트 관리__
		1. [애플리케이션 테스트](#애플리케이션-테스트)
		2. [애플리케이션 테스트의 분류](#애플리케이션-테스트의-분류)
		3. [테스트 기법에 따른 애플리케이션 테스트](#테스트-기법에-따른-애플리케이션-테스트)
		4. [개발 단계에 따른 애플리케이션 테스트](#개발-단계에-따른-애플리케이션-테스트)
		5. [통합 테스트](#통합-테스트)
		6. [애플리케이션 테스트 프로세스](#애플리케이션-테스트-프로세스)
		7. [테스트 케이스/시나리오/오라클](#테스트케이스/시나리오/오라클)
		8. [테스트 자동화 도구](#테스트-자동화-도구)
		9. [결함 관리](#결함-관리)
		10. [애플리케이션 성능 분석](#애플리케이션-성능-분석)
		11. [애플리케이션 성능 개선](#애플리케이션-성능-개선)

---

1. ### 애플리케이션 테스트

	1. __애플리케이션 테스트의 개념__

		* 애플리케이션의 **잠재된 결함을 찾아내는 과정**
		* 테스트 전 개발한 소프트웨어의 유형을 분류하고 특성을 정리해서 중점적으로 테스트할 사항을 정리

		1. **Validation** : 개발된 소프트웨어가 요구사항을 만족하는지 **사용자 입장**에서 확인
		2. **Verification** : 기능을 제대로 수행하고 명세서에 맞게 만들었는지 **개발자의 입장**에서 점검

	2. **애플리케이션 테스트의 필요성**

		* **미리 오류를 발견하고 새로운 오류의 유입을 예방**
		* 사용자의 요구사항에 만족하는지 테스트해 **제품의 신뢰도 향상**

	3. **애플리케이션 테스트의 기본원리**

		* **잠재적인 결함을 줄일 수 있지만 소프트웨어 자체 결함이 없다곤 할 수 없음**
		* 결함은 특정 모듈에 집중되 있어 **애플리케이션의 20%에 해당하는 코드에서 80%의 결함이 발견된다고 하여 파레토법칙을 적용하기도  한다**
		* **살충제 패러독스 현상**을 방지하기 위해 테스트케이스를 지속적으로 보완 및 개선
		* 테스트를 정황에 따라 다르게 진행
		* **결함을 모두 제거해도 사용자의 요구사항을 만족할 수없으면 안됨**
		* 작은 부분에서 시작해서 점점 확대하며 진행

2. ### 애플리케이션 테스트의 분류
   
    1. **프로그램 실행 여부**
    
        1. **정적 테스트**
            * 프로그램을 실행하지 않고 소스코드나 명세서를 분석하여 테스트
            * 개발 초기에 결함을 발견할 수 있어 **비용이 절감**
            * **워크 스루, 인스펙션, 코드 검사 등**
        2. **동적 테스트**
            * 프로그램을 실행하여 테스트
            * 개발의 모든 단계에서 진행
            * **블랙박스 테스트, 화이트 박스 테스트**
        
    2. **테스트 기반**
    
        1. **명세 기반 테스트**
            * **사용자의 요구사항**을 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
            * 동등 분할, 경계 값 분석
        2. **구조 기반 테스트**
            * **소프트웨어 내부 논리 흐름**에 따라 테스트 케이스를 만들어 테스트
            * 구문, 결정, 조건 등
        3. **경험 기반 테스트**
            * **테스터의 경험을 기반으로 테스트**
            * 요구사항에 대한 명세가 부족하거나 시간의 제약이 있는 경우
            * 에러 추정, 체크리스트, 탐색적 테스팅
    4. **시각**
    
        1. **Validation 테스트**
        
            * 사용자의 시각에서 결과를 테스트
            * 요구사항을 만족하면서 정상적으로 동작하는지 테스트
        2. **Verification 테스트**
            * 개발자의 시각에서 과정을 테스트
            * 명세서에 맞게 완성되었는지 테스트
    
    4. **목적에 따른 테스트**
        1. **Recovery** : 결함을 주고 잘 복구되는지 테스트
        2. **Security** : 시스템 보호 도구가 불법적인 침입으로부터 보호할 수 있는지
        3. **Stress** : 과부하 시 정상적으로 실행되는지
        4. **Performance** : 응답 시간, 처리량 테스트
        5. **Structure** : 내부의 논리적인 경로, 소스 코드 복잡도 등을 평가
        6. **Regression** : 변경 혹은 수정에 따른 새로운 결함이 없는지를 테스트
        7. **Parallel** : 기존의 소프트웨어와 변경된 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트
	
3. ### 동적 테스트

	1. **화이트 박스 테스트**
		* 모듈의 원시 코드를 오픈하여 **논리적인 모든 경로를 한번 이상 실행하면서** 테스트하여 케이스를 설계
		* **테스트 과정 초기에 진행**
		* 설계된 절차에 초점을 둔 **구조적 테스트**
		* 모듈 안의 동작을 직접 관찰
	2. **화이트 박스 테스트의 종류**
		1. **기초 경로 검사**
			* 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법
			* **테스트 측정 결과를 통해 실행 경로의 기초를 정의**
		2. **제어 구조 검사**
			1. **조건 검사** : 프로그램 내의 논리적 조건을 테스트
			2. **루프 검사** : 프로그램 내의 반복 구조에 초점을 맞춰 테스트
			3. **데이터 흐름 검사** : 프로그램 내의 변수의 정의와 사용자의 위치에 초점을 맞춰 테스트
    3. **화이트 박스 테스트 검증 기준**
        1. 문장 검증 : 모든 구문이 한 번 이상 수행되도록
        2. 분기 검증 : 모든 조건문이 한 번 이상 수행
        3. 조건 검증 : 모든 조건문에 대해 참/거짓인 경우가 한번 이상 수행되도록
        4. 분기/조건 검증 : 모든 조건문과 조건문에 포함된 개별 조건식의 결과가 참/거짓인 경우가 한번 이상 수행되도록 설계
    4. **블랙박스 테스트**
        * 소프트웨어가 수행할 특정 기능을 알기 위해 기능이 완전히 작동되는 것을 입증하는 테스트
        * 테스트 과정의 후방부에 진행
        * 사용자의 요구사항 명세를 보면서 구현된 기능 테스트
        * 소프트웨어 인터페이스에서 실시 
    5. **블랙박스 테스트의 종류**
        1. **Equivalence Partitioning Testing** : 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사 
        2. **Boundary Value** : **입력 조건의 경계값**을 테스트 케이스로 선정하여 검사
        3. **Cause-Effect Graphing** : 입력 데이터 간의 관계와 출력에 영향을 미츠는 상황을 분석 후 효용성이 높은 테스트 케이스 선정하여 검사
        4. **Error Guessing** :  **과거 경험이나 확인자의 감각으로 테스트**
        5. **Comparison Testing**  : 여러 프로그램에 동일한 테스트 자료를 제공하여 동일한 출력 나오는지 검사

4. ### 개발 단계에 따른 애플리케이션 테스트

	1. **개발 단계에 따른 애플리케이션 테스트**

		* ![소프트웨어생명주기v-모델](https://user-images.githubusercontent.com/52272332/89407681-2a9a3880-d75a-11ea-91cc-6e9bd3968199.png)

	2. **Unit 테스트**

		* 코딩 직후 모듈이나 컴포넌트에 초점을 맞춰 테스트

		* 인터페이스, 외부적 I/O, 자료 구조 등을 검사

		* 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행

		* |   테스트 방법    |                         테스트 내용                          |      테스트 목적      |
			| :--------------: | :----------------------------------------------------------: | :-------------------: |
			| 구조 기반 테스트 | 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트를 시행 |  제어 흐름 조건 결정  |
			| 명세 기반 테스트 |        목적 및 실행 코드 기반의 블랙박스 테스트 시행         | 동등 분할 경계값 분석 |

	3. **Integration 테스트**

		* 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성하는 과정의 테스트
		* 뒤에 더 자세하게 나옴

	4. **System Testing**

		* 개발된 소프트웨어가 원하는 환경에서 수행되는지 테스트
		* **환경적인 장애를 최소화하기 위해서** 실제 환경과 유사하게 만든 테스트 환경에서 진행
		* 기능적 요구사항 : 명세서 기반의 블랙박스
		* 비 기능적 요구사항 : 구조적 요소에 대한 화이트박스 테스트

	5. **Acceptance Testing** 

		* 인수 테스트는 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트 하는 방법이다.

		* |     테스트 종류      |                             설명                             |
			| :------------------: | :----------------------------------------------------------: |
			|  사용자 인수 테스트  |          사용자가 시스템 사용의 적절성 여부를 확인           |
			| 운영상의 인수 테스트 |             시스템 관리자가 시스템 인수 시 수행              |
			|   계약 인수 테스트   |               계약상의 조건을 준수하는지 확인                |
			|   규정 인수 테스트   |                규정에 맞게 개발되었는지 확이                 |
			|   **알파 테스트**    | **개발된 환경에서 사용자가 개발자 앞에서 수행**<br />통제된 환경에서 함께 이루어짐 |
			|   **베타 테스트**    | **사용자의 환경에서 사용자가 직접 테스트 수행**<br />통제되지 않은 상태에서 진행되며 문제점을 기록하여 개발자에게 보내준다. |

5. ### 통합 테스트

	1. **Integraditon Test**

		* 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성하는 과정에서 테스트

		* 모듈 간 또는 통합된 컴포넌트 간 상호 작용 오류 검사

		* | 비점진적 통합방식 | 1. 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트<br />2. 빅뱅 통합 테스트 방식<br />3. 오류 발견 및 장애 위치 파악이 어려움 |
		  | :---------------: | :----------------------------------------------------------: |
      |  점진적 통합방식  | 1. 모듈 단위로 단계적으로 통합하면서 테스트<br />2. 하향식/상향식/혼합식 테스트방식<br />3. 오류 수정이 용이하고 인터페이스 관련 오류를 완전히 테스트할 수 있음 |
		
	2. **Top Down Integration Test**
	
		* 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
		* **깊이 우선 통합법이나 넓이 우선 통합법 사용**
		* 상위 모듈에선 테스트 케이스 사용이 어려움
		* **Stub** : 상위 모듈은 있지만 하위 모듈이 없는 경우 하위 모듈 대체 
		* **단계**
			1. 주요 제어 모듈은 작성된 프로그램으로 하고 **주요 제어 모듈에 종속모듈은 Stub으로 대체한다.**
			2. 통합 방식에 따라 하위 모듈인 Stub들이 한 번에 하나씩 실제 모듈로 교체
			3. 모듈이 통합될 때 마다 테스트
			4. 회귀 테스트 실시
	
	3. **Botton up Integration Test**
	
		* 하위 모듈에서 상위 모듈 방향으로 통합하며 테스트
		* 하나의 주요 제어 모듈과 종속 모듈의 그룹인 **Cluster**가 필요
		* **Driver** : 상위 모듈 없이 하위 모듈이 있는 경우 하위 모듈 구동
		* **단계**
			1. **하위 모듈을 Cluster**로 결합
			2. 상위 모듈에서 데이터의 입출력을 확인하기 위해 더미 모듈인 드라이버를 작성
			3. 통합된 Cluster 단위 테스트
			4. Cluster는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체
	
	4. **혼합식 통합 테스트**
	
		* 하위 수준에서는 상향식 통합
		* 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원
		* 샌드위치 통합
	
	5. **회귀 테스팅**
	
		* 이미 테스트된 프로그램의 테스팅을 반복
		* 통합 테스트로 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인
	
8. ### 애플리케이션 테스트 프로세스

     1. **애플리케이션 테스트 프로세스**
     	* 개발된 소프트웨어가 제대로 만들어 졌는지 테스트하는 절차
     	* 테스트르 마치면 테스트 계획서, 케이스, 시나리오, 결과서가 산출
     	* **에러는 빨리 발견될 수록 좋음**
     	* **테스트 계획 -> 분석 및 디자인 -> 테스트 케이스 및 시나리오 작성 -> 테스트 수행 -> 결과 평가 및 리포팅 -> 결함 추적 및 관리**
     2. **테스트 계획**
     	* 테스트를 계획 단계에서는 **프로젝트 계획서 및 요구 명세서**를 기반으로 테스트 목표를 정의하고 **대상 및 범위를 설정**
     	* 테스트 대상의 시스템 구조 파악
     	* 조직 및 비용 산정
     	* 시작 및 종료 조건 정의
     		1. **시작조건**
     			* 테스트 계획, 일정, 환경 구축, 요구사항 명세서, 투입 조직 참여인원등이 완료되면 테스트가 시작될 수 있도록 조건을 정의한다.
     			* 모든 조건을 만족하지 않아도 테스트를 시작하도록 지정가능
     		2. **종료조건**
     			* 정상적으로 테스트를 완료한 경우, 테스트 일정이 만료된 경우, 테스트 비용이 모두 소진된 경우
     			* 업무 기능의 중요도에 따라 테스트 종료 조건을 다르게 정의 가능
     		3. 테스트 계획서를 작성
     3. **테스트 분석 및 디자인**
     	* 테스트의 목적과 원칙을 검토하고 사용자의 요구사항 분석 
     	* 테스트에 대한 리스크 분석 및 우선순위 결정
     	* 테스트 데이터,환경,도구를 준비
     4. **테스트 케이스 및 시나리오 작성**
     	
     	* 테스트 케이스를 작성, 검토 및 확인 후 시나리오 작성
     5. **테스트 수행**
     	* **테스트 환경**을 구축한뒤 수행한다.
     		1. 하드웨어 : 서버, 클라, 네트워크 등 장비 설치
     		2. 소프트웨어 : 구축된 하드웨어 환경에 테스트할 소프트웨어 장치
     		3. 가상 시스템 : 가상 머신 기반의 서버또는 클라우드 환경 구축하고 네트워크는 VLAN 과같은 기법을 이용하여 논리적 분할
     	* 결과를 측정하여 기록한다.
     6. **테스트 결과 평가 및 리포팅**
     	* 테스트 결과를 분석하여 테스트 결과 작성
     	* 결함 내용 및 결함 재현 순서 등 결함을 중점적으로 기록
     7. **결함 추적 및 관리**
     	* 테스트 수행 후 결함이 어디에서 발생했고 어떤 결함인지 추적하고 관리
     	* 결함 관리 프로세스
     	* **발견 -> 등록 -> 분석 -> 확정 -> 확당 -> 조치 -> 조치 검토 및 승인**

9. ### 테스트 케이스/시나리오/오라클

     1. **테스크 케이스**
     	* 사용자의 요구사항이 준수되었는지 확인하기 위한 테스트 망혹에 대한 명세서
     	* 명세 기반 테스트의 설계 산출물
     2. **테스트 케이스 작성 순서**
     	1. **테스트 계획 검토 및 자료 확보**
     	2. **위험 평가 및 우선순위 결정**
     	3. **테스트 요구사항 정의**
     	4. **테스트 구조 설계 및 테스트 방법 결정**
     	5. **테스트 케이스 정의**
     	6. **테스트 케이스 타당성 확인 및 유지보수**
     3. **Test Scenario**
     	* 테스트 케이스를 적용하는 구체적인 절차, 사전 조건, 입력 데이터 등 명세
     	* 시나리오를 통해 미리 테스트 순서를 정함으로써 **테스트 항목을 빠짐없이 수행 가능**
     4. **테스트 시나리오 작성시 유의사항**
     	1. **시나리오는 시스템별, 모듈별, 항목별 등과 같이 여러개의 시나리오로 분리하여 작성**
     	2. **사용자의 요구사항과 설계 문서 등을 토대로 작성**
     	3. **시나리오는 Use Case간 업무 흐름이 정상적인지를 테스트할 수 있어야 한다.**
     	4. 개발된 모듈 또는 프로그램 간의 연계가 정상적으로 동작하는지 테스트할 수 있도록 작성
     5. **Test Oracle**
     	* 테스트 오라클은 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교 하는 방법
     	* 특징
     		1. 제한된 검증 : 테스트 오라클은 **모든 테스트 케이스에 적용할 수 없다**
     		2. 수학적 기법 : **테스트 오라클의 값을 수학적 기법을 이용하여 구할 수 있다.**
     		3. 자동화 기능 : **테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정 등을 자동화 할 수 있다**
     6. **테스트 오라클의 종류**
     	1. **True 오라클**
     		* 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클
     		* 발생된 모든 오류 검출 가능
     		* 주로 항공기, 은행, 발전소 등 미션 크리티컬한 업무에 사용
     	2. **Sampling 오라클**
     		* 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클이다.
     		* 일반적인 업무, 게임, 오락 등에 사용
     	3. **Heuristic** 오라클
     		* 샘플링 오라클을 개선한 오라클로, 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공한다.
     		* 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클이다.
     	4. **Consisent 오라클**
     		* 애플리케이션의 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지 확인하는 오라클이다.

10. ### 테스트 자동화 도구

     1. __테스트 자동화의 개념__
        
         * 반복적인 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용하여 쉽고 효율적으로 테스트 수행
     2. __테스트 자동화 도구의 장단점__
         * **장점**
             1. 반복적인 작업을 자동화해 인력 및 시간 절감
             2. 향상된 테스트 품질 보장
             3. 사용자의 요구사항 등을 일관성 있게 검증
             4. 테스트 결과에 대한 객관적인 평가 기준 제공
             5. 테스트 결과를 다양한 표시 형태로 제공
             6. UI가 없는 서비스도 정밀 테스트 가능
         * **단점**
             1. 사용방법에 대한 교육 및 학습 필요
             2. 자동화 도구를 프로세스 단계별로 적용하기 위한 시간, 비용 , 노력이 필요 
             3. 비공개 도구는 돈이 들어감
     3. __테스트 자동화 수행시 고려사항__
         * 모든 과정이 아닌 그때그떄 맞는 도구를 선택
         * 자동화 도구를 고려하여 프로젝트 일정 계획
         * 프로젝트 초기에 테스트 엔지니어 투입 시기 계획
     4. **테스트 자동화 도구의 유형**
         1. **정적 분석 도구** : 프로그램을 사용하지 않고 소스코드를 통해 결함 발견
         2. **테스트 실행 도구** : 스크립트 언어를 사용하여 테스트 진행
         3. **성능 테스트 도구** : 가상의 사용자를 만들어 테스트 수행
         4. **테스트 통제 도구** : 테스트 계획 및 관리, 수행, 결함 관리 등을 수행
         5. **테스트 하네서 도구**
             * 테스트가 실행될 환경을 시뮬레이션하여 컴포넌트 및 모듈이 정상적으로 테스트되도록함
         * **구성요소**
             1. Test Driver : 테스트 대상의 하위 모듈 호출하고 수행 후 결과 도출하는 도구
             2. Test Stub : 단순히 수행하는 도구로 일시적으로 필요한 조건만을 갖고 있는 테스트용 모듈
             3. Test Suites : 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
             4. Test Case : 사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 명세서
             5. Test Script : 자동화된 테스트 실행 절차 명세서
             6. Mock Object : 사전에 사용자의 행위를 조건부로 입력해 두면 , 그 상황에 맞는 예정된 행위를 수행하는 객체
     5. **테스트 수행 단계별 테스트 자동화 도구**
         1. **테스트 계획**
             * 요구사항 관리 : 사용자의 요구사항 정의 및 변경 사항 관리 도구
         2. **테스트 분석/설계**
             * 테스트 케이스 생성 : 테스트 데이터 및 테스트 케이스 작성을 지원
         3. **테스트 수행**
             * 테스트 자동화
             * 정적 분석 : 코딩 표준, 런타임 오류 등 검증
             * 동적 분석 : 대상 시스템의 시뮬레이션을 통해 오류 검출
             * 성능 테스트 : 가상의 사용자를 생성하여 시스템의 처리 능력을 측정하는 도구
             * 모니터링 : CPU, Memory 등과 같은 시스템 자원의 상태 확인 및 분석을 지원하는 도구
         4. **테스트 관리**
             * 커버리지 분석 : 테스트 완료 후 테스트의 충분성 여부 검증을 지원하는 도구
             * 형상 관리 : 다양한 도구 및 데이터 관리
             * 결함 추적/관리 : 발생한 결함 추적 및 관

11. ### 결함 관리

    1. **Fault 정의**
    
        * 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 것
    
    2. **결함 관리 프로세스**
    
        * 애플리케이션 테스트에서 발견된 결함을 처리
        * ![결함 관리 프로세스](https://user-images.githubusercontent.com/52272332/89407678-29690b80-d75a-11ea-9ce7-1de9f8a4fa6e.jpeg)
    
    3. **결함 상태 추적**
       
        * 테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하여 관리해야 함
    
        1. **결함 분포** : 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정
        2. **결함 추세** : 테스트 진행 시간에 따른 결함 수의 추이 분석
        3. **결함 에이징** : 특정 결함 상태로 지속되는 시간 측정
    
    4. **결함 추적 순서**
       
        * 결함이 발견되고 해결될떄 까지의 과정
        * **결함 등록 -> 검토 -> 할당 -> 수정 -> 조치 보류 -> 해제**
    
    5. **결함 분류**
       
        1. **시스템 결함** : 시스템 다운, 작동 정지 응답 지연 등 애플리케이션 환경이나 DB처리에서 발생된 결함
        2. **기능 결함** : 사용자의 요구사항 미반영/불일치, 타 시스템과 연동시 결함
        3. **GUI 결함** : UI 비일관성 타입 표시 오류 부정확한 커서/메시지 화면 설계 결함
        4. **문서 결함** : 기획자,사용자,개발자 간의 의사소통 및 기록이 원활하지 않아 발생된 결함
    
    6. **결함 심각도**
       
        * 발견된 결함 처리에 대한 신속성을 나타내는 척도
        * 결함의 중요도와 심각도에 따라 설정되고 수정 여부 결정
    
    7. **결함 우선순위**
       
        * 결함의 우선순위는 발견된 결함 처리에 대한 **신속성을 나타내는 척도로, 결함의 중요도와 심각도에 따라 설정**되고 수정 여부가 결정된다.
        * Critical, High, Medium, Low 또는 즉시 해결, 주의 요망, 대기 ,개선 권고 등으로 분류
        
    8. **결함 관리 도구**
       
        * 결함을 체계적으로 관리할 수 있도록 해준다.
        
        1. Mantis : 소프트웨어 설계 시 단위 별 작업 내용을 기록할 수 있어 결함 및 이슈 관리, 추적관리 
        2. Trac : 결함 추적 및 통합 관리 도구
        3. Redmine : 프로젝트 관리 및 결함 추적 도구
        4. Bugzilla : 결함을 지속적으로 관리하고 심각도와 우선순위를 지정할 수 있는 도구

12. ### 애플리케이션 성능 분석

    1. **애플리케이션 성능**
    
        * 사용자가 요구한 기능을 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도
        * 측정 지표 : 처리량, 응답 시간, 경과 시간, 자원 사용률
    
    2. **성능 테스트 도구**
    
        * 애플리케이션 성능을 테스트하기 위해 부하나 스트레스를 가해 성능 측정 지표를 점검하는 도구
        
        1. Jmeter : 다양한 프로토콜의 지원하는 부하 테스트 도구 
        2. LoadUI : 사용자의 편리성이 강화된 부하 테스트 도구
        3. OpenSTA : HTTP, HTTPS 프로토콜에 대한 부하 테스트 및 생산품 모니터링
    
    3. **시스템 모니터링 도구**
    
        * 애플리케이션 실행 중 시스템 자원의 사용량을 확인하고 분석하는 도구
        * 성능 저하의 원인/ 시스템 부하량/ 사용자 분석과 같은 시스템을 안정적으로 운영할 수 있는 기능 제공
        * Scouter, Zabbix
    
    4. **애플리케이션 성능 저하 원인 분석**
    
        * 애플리케이션을 DB에 연결하기 위해 커넥션 객체를 생성하거나 쿼리를 실행하는 애플케이션 로직에서 자주 발생
        * JDBC, ODBC 미들웨어 사용 후 종료하지 않아서 연결 누수 발생한 경우

13. ### 애플리케이션 성능 개선

    1. **소스 코드 최적화**
        * 나쁜건 배제하고 클린으로 작성
        * **클린 코드** : 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순 명료한 코드
        * **나쁜 코드** : 로직이 복잡하고 이해하기 어려우며 코드의 로직이 서로 얽혀 있는 스파게티 코드
        * **클린 코드 작성 원칙**
        1. 가독성
        2. 단순성
        3. 의존성 배제
        4. 중복성 최소화
        5. 추상화
    2. **소스 코드 최적화 유형**
        1. 클래스 분할 배치
        2. Loosely Coupled
        3. 코딩 형식 준수
        4. 좋은 이름 사용
        5. 적절한 주석문 사용
    3. **소스 코드 품질 분석 도구**
       
        * 코딩 스타일, 코딩 표준 ,복잡도 , 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 도구로써 동적, 정적으로 나뉜다.
    * **정적 분석 도구**
        1. 실행하지 않고 코딩 표준이나 스타일 결함 확인
        2. 개발 초기에 결함을 찾는데 사용되고 완료시점엔 품질 검증 정도
        3. pmd, cppcheck,checkstyle
    * **동적 분석 도구**
        1. 작성한 소스 코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구이다.
        2. Avalanche, Valgrind 등
    
