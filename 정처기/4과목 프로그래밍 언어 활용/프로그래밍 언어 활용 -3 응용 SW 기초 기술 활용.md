### 주벼정보처리기사

---

1. **프로그래밍 언어 활용**
	1. **응용 SW 기초 기술 활용**
		1. [운영체제의 개념](#운영체제의-개념)
		2. [Windows](#Windows)
		3. [UNIX/LINUX/MacOS](#UNIX/LINUX/MacOS)
		4. [기억장치 관리의 개요](#기억장치-관리의-개요)
		5. [주기억장치 할당 기법](#주기억장치-할당-기법)
		6. [가상기억장치 구현 기법 / 페이지 교체 알고리즘](#가상기억장치-구현-기법-/-페이지-교체-알고리즘)
		7. [가상기억장치 기타 관리 사항](#가상기억장치-기타-관리-사항)
		8. [프로세스의 개요](#프로세스의-개요)
		9. [스케줄링](스케줄링)
		10. [환경 변수](#환경 변수)
		11. [운영체제 기본 명령어](#운영체제-기본-명령어)
		12. [인터넷](#인터넷)
		13. [OSI 참조 모델](#OSI-참조-모델)
		14. [네트워크 관련 장비](#네트워크-관련-장비)
		15. [프로토콜의 개념](#프로토콜의-개념)
		16. [TCP/IP](#TCP/IP)

---

1. ### 운영체제의 개념

	1. **운영체제의 정의**

		* 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임

		|    사용자     |
		| :-----------: |
		| 응용 프로그램 |
		|   유틸리티    |
		|   운영체제    |
		|   하드웨어    |

	2. **운영체제의 목적**

		* **처리 능력 향상, 사용 가능도 향상, 신뢰성 향상, 반환 시간 단축 등**
		* **운영체제의 성능평가 기준**
			1. 처리능력 : 일정 시간 내에 시스템이 처리하는 일의 양
			2. 반환 시간 : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸리는 시간
			3. 사용 가능도 : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
			4. 신뢰도 : 주어진 문제를 정확하게 해결하는 정도

	3. **운영체제의 기능**

		* **Processor, CPU, 주기억장치, 입 출력장치, 파일 정보 등을 관리**
		* 자원을 효율적으로 관리하기 위해 스케쥴링 기능 제공
		* 사용자와 시스템 간 편리한 인터페이스 제공
		* 각종 하드웨어와 네트워크를 관리 제어
		* 데이터 관리, 데이터 및 자원의 공유 기능 제공
		* 시스템의 오류 검사 및 복구
		* 자원 보호 기능 제공
		* 입 출력에 대한 보조 기능 제공
		* 가상 계산기 기능 제공

	4. **운영체제의 주요 자원 관리**

		1. 프로세스 관리 : 프로세스 스케쥴링 및 동기화 관리
		2. 기억장치 관리 : 프로세스에게 메모리 할당 및 회수 관리
		3. 주변장치 관리 : 입 출력장치 스케쥴링 및 전반적인 관리
		4. 파일 관리 : 파일의 생성과 삭제, 변경, 유지 등의 관리
		5. **순서 : 하드웨어 -> CPU -> 주기억장치 -> 프로세스 관리 -> 주변장치 관리 -> 파일 시스템 -> 사용자 프로세스**

	5. **운영체제의 종류**

		* Windows, UNIN, MacOS 등

2. ### Windows

	1. **Windows의 개요**
		* 마이크로소프트에서 개발한 운영체제
	2. **Windows 시스템의 특징**
		* GUI : 키보드 명령어로 수행이 아닌 마우스로 작업가능
		* **선점형 멀티테스킹** : 동시에 여러 개의 프로그램을 실행하는데 멀티태스킹을 하면서 운영체제가 각 작업의 CPU이용을 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환
		* Plug and Play : 하드웨어를 설치할 때 해당 하드웨어를 사용하는데 필요한 시스템 환경을 운영체제가 자동으로 구성해주는 기능 
		* Object Linking and Embedding : 다른 응용 프로그램에서 작성된 문자나 그림 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입 가능
		* Single User : 컴퓨터 한대를 한 사람이 독점 사용

3. ### UNIX/LINUX/MacOS

	1. **UNIX의 개요 및 특징**
		* 1960년대 Bell 연구소에서 MIT 공동 개발
		* 시분할 시스템을 위해 설계된 대화식 운영체제
		* 소스코드가 개방형 시스템으로 구성
		* 대부분 C로 작성되어 이식성이 높으며 장치간 호환성이 좋다
		* Multi User Tasking 지원
		* 트리 구조의 파일 시스템을 가진다.
	2. **UNIX 시스템의 구성**
		1. **Kernel**
			* 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행됨
			* 하드웨어를 보호하고 프로그램과 하드웨어 간의 인터페이스 역할을 담당
			* 프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스 간 통신, 데이터 전송 및 변환 등 여러 가지 기능 수행
		2. **Shell**
			* 명령어를 인식하여 수행하는 명령어 해석기
			* 시스템과 사용자 간의 인터페이스 담당
			* DOS의 COMMAND.COM과 같은 기능 수행
			* 주기억장치에 상주하지 않고 명령어가 포함된 파일 형태로 존재
			* 보조기억장체서 교체 처리 가능
			* 파이프라인 기능 지원
			* **파이프 라인 : 둘 이상의 명령을 함께 묶어 처리한 결과를 다른 명령의 입력으로 전환하는 기능**
			* 입출력 재지정을 통해 입력과 출력의 방향 변경 가능 -> input output 제어
			* 공용 Shell이나 사용자가 만들 Shell을 사용할 수 있음
		3. **Utility Program**
			* 사용자가 작성한 외부 프로그램을 처리
			* DOS에서의 외부 명령어에 해당
			* 에디터, 컴파일러, 인터프리터, 디버거 등
		4. **LINUX의 개요 및 특징**
			* 1991년 리누스 토발즈가 UNIX기반으로 개발한 운영체제
			* 프로그램 소스 코드가 무료로 공개되어 있어 사용자가 원하는 기능 추가 가능하고 다양한 플랫폼에 설치 , 재배포가능
			* UNIX와 완벽하게 호환
			* 대부분 특징이UNIX와 동일
		5. **MacOS**
			* 1980년대 애플이 만듬
			* 드라이버설치가 install, uninstall로 단순

4. ### 저장장치 관리의 개요

	1. **저장장치 계층 구조의 특징**
		* 주기억장치는 각기 자신의 주소를 가지는 워드 또는 바이트들로 구성되어 주소를 이용하여 접근
		* 보조기억장치에 있는 프로그램이나 데이터는 CPU가 직접 엑세스 할 수 없다.
		* 보조기억장치에 있는 데이터는 주기억장치에 적재된 후 cpu에 의해 엑세스
	2. **기억장치의 관리 전략의 개요**
		* Fetch, placement, replacement 전략
	3. **Fetch**
		* 보조기억장치에 보관중인 데이터를 언제 주기억장치에 적재할 것인지를 결정하는 전략
		* **요구 반입** : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재
		* **예상 반입** : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재
	4. **Placement**
		* 새로 반입되는 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
		* First Fit
		* Best Fit
		* Worst Fit
		* **단편화**
			1. 내부 단편화 : 배치 후 남은 공간
			2. 외부 단편화 : 배치를 못해 빈 공간으로 남아있는 공간
	5. **Replacement**
		* 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터가 배치하려고 할 때, 이미 사용 중인 영역에서 어느 영역으로 교체할 것인지를 결정하는 전략
		* FIFO, OPT, LRU, NUR, SCR 등

5. ### 주기억장치 할당 기법

	1. **주기억장치 할당의 개념**

		* 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용

		1. **연속 할당 기법**
			* 프로그램을 주 기억장치에 연속으로 할당하는 기법
			* 단일 분할 할당 기법 : 오버레이, 스와핑
			* 다중 분할 기법 : 고정 분할 할당 기법, 동적 분할 할당 기법 
		2. **분산 할당 기법**
			* 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법
			* 페이징 기법, 세그먼테이션 기법

	2. **단일 분할 할당 기법**

		* 주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한순간에 오직 한명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법
		* **Overlay 기법**
			1. 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
			2. 보조기억장체 저장된 하나의 프로그램을 여러개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장체 적재하여 프로그램 실행
		* **Swapping 기법**
			1. 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다가 필요에 따라 다른 프로그램과 교체하는 기법

	3. **다중 분할 할당 기법**

		1. **고정 분할 할당 기법** : 프로그램에 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비 중인 프로그램을 각 영역에서 할당하여 수행하는 기법
		2. **가변 분할 할당 기법** : 미리 주기억장치에 분할해 놓는 것이 아닌 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할 

6. ### 가상기억장치 구현 기법 / 페이지 교체 알고리즘

	1. **가상 기억장치의 개요**
		* **보조기억장치의 일부를 주기억장치처럼 사용하는 것**
		* 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용할 수 있음
		* **프로그램을 여러 작은 블록 단위로 나누어서 가상 기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장체 불연속적으로 할당하여 처리**
		* 주기억장치의 이용률과 다중 프로그래밍의 **효율 상승**
		* 가상기억장치에 저장된 프로그램을 실행하려면 가상 기억장치의 주소를 주기억장치의 주소로 바꾸는 **주소변환 작업이 필요**
		* **연속 할당 방식에서 발생할 수 있는 단편화 해결 가능**
	2. **Paging 기법**
		* 가상기억장치의 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법
		* 프로그램을 일정한 크기로 나눈 크기를 페이지라 하고 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임이라고 하낟.
		* 외부 단편화는 발생하지 않으나 내부 단편화는 가능
		* Mapping 작업을 위해 페이지 맵 테이블이 필요함. -> 비용증가 속도 저하
	3. **Segmentation 기법**
		* 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 방법
		* 프로그램을 논리적인 크기로 나눈 단위가 세그먼트다
		* 내부 단편화는 없으나 외부 단편화는 생긴다.
		* Mapping 작업을 위해 세그먼트 맵 테이블이 필요함
		* 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며 이를 위해 기억장치 보호키가 필요
		* **가상 메모리**
			1. 고정 크기 분할 : 페이지
			2. 가변 크기 분할 : 세그먼트
	4. **페이지 교체 알고리즘**
		1. FIFO
		2. LRU
			* 페이지마다 Counter나 Stack을 두어 가장 오래전에 사용된 페이지 교체
		3. LFU
		4. NUR
			* 최근 사용 여부를 확인하기 위해 페이지마다 참조 비트와 변형 비트를 사용

7. ### 가상 기억장치 기타 관리 사항

	1. **페이지 크기에 따른 특징**

		* **작은 경우**
			1. 단편화와 주기억장치로 이동하는 시간 감소
			2. 불필요한 내용이 적재될 확률이 낮아 Working Set이 효율적으로 유지
			3. Locality에 더욱 일치하여 기억장치의 효율 상승
			4. 페이지 맵 테이블 크기가 커지므로 매핑 속도가 늦어짐
			5. 디스크 접근 횟수가 많아져 전체적인 입출력 시간이 늘어남
		* **큰 경우**
			1. 단편화와 주기억장치로 이동하는 시간이 증가
			2. 프로세스 수행에 불필요한 내용까지 적재될 수 있음
			3. 페이지 맵 테이블 크기가 작아지므로 매핑 속도가 빨라짐
			4. 디스크 접근 횟수가 줄어 전체 입출력이 줄어든다. 

	2. **Locality**

		* 프로세스가 실행되는 동안 주기억장치로 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론
		* 스래싱을 방지하기 위한 워킹 셋 이론의 기반
		* 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법
		* 프로세스가 집중적으로 사용하는 페이지를 알아내는 방법

		1. **Temporal Locality**
			* 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 엑세스 하는 현상
			* 시간 구역성이 이루어지는 기억 장소 : 반복, 스택, 부프로그램, 증감, 집계변수 등
		2. **Spatial Locality**
			* 프로세스 실행 시 일정 위치의 페이지를 집중적으로 엑세스 하는 현상
			* 공간 구역성이 이루어지는 기억 장소 : 배열 순회, 순차적 코드 실행, 프로그래머들이 관련된 변수들을 서로 근처에 선언하여 할당되는 기억 저장소
		3. **Working set**
			* 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
			* 자주 참조디는 워킹 셋을 주이거장치에 상주시켜 페이지 부재 및 페이지 교체 현상이 줄어들어 프로스세의 기억장치 사용이 안정됨
			* 시간에 따라 변화한다.
		4. **페이지 부재 빈도 방식**
			* 페이지 부재 빈도는 페이지 부재가 일어나는 횟수
			* 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임 수를 조정하여 적정 수준으로 유지하는 방식
			* 운영체제는 프로세스 실행 초기에 임의의 페이지 프레임 할당 후 페이지 부재율에 따라 프레임을 할당하거나 회수
		5. **프리 페이징**
			* 처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재하는 기법
		6. **Tharsing**
			* **프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상**
			* 다중 프로그래밍 시스템이나 가상 기억장치를 사용하는 시스템에서 하나의 프로세스 수행 중 자주 페이지 부재가 발생하면 나타난다.
			* 전체 프로세스 성능이 저하된다.
			* 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고 CPU의 이용률은 급격히 감소됨
			* **스래싱 현상 방지 방법**
				1. 다중 프로그래밍을 적정 수준으로 유지
				2. 페이지 부재 빈도를 조절
				3. 워킹 셋 유지
				4. 부족한 자원 증설, 프로세스 중단
				5. CPU성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영

8. ### 프로세스의 개요

	1. **프로세스의 정의**
		* 프로세스에 의해 처리되는 사용자 프로그램이나 시스템 프로그램을 의미
		* 실행 중인 프로그램을 의미하며 작업 또는 Task라고도 함
		* 프로세스의 또 다른 형태
			1. PCB를 가진 프로그램
			2. 실기억 장치에 저장된 프로그램
			3. 디스패치가 가능한 단위
			4. 프로시저가 활동 중인 것
			5. 비동기적 행위를 일으키는 주체
			6. 지정된 결과를 얻기 위한 일련의 계통적 동작
			7. 목적 또는 결과에 따라 발생되는 사건들의 과정
			8. 운영체제가 관리하는 실행 단위
	2. **Process Control Block**
		* 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓은 곳
		* 프로세스가 생성될 때마다 고유한 PCB를 생성하고 프로세스 완료 시 제거 됨
		* 저장되는 정보
			1. PS의 현재 상태
			2. 포인터
			3. PS 고유 식별자
			4. 스케줄링 및 PS의 우선순위
			5. CPU레지스터정보
			6. 주기억장치 관리 정보
			7. 입출력 상태 정보
			8. 계정 정보
	3. **프로세스 상태 전이**
		* 제출 : 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
		* 접수 : 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장한 상태
		* 준비
			1. 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
			2. 프로세스는 준비상태 큐에서 실행 준비
			3.  Job 스케줄러에 의해 수행
		* 실행
			1. 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
			2. 프로세스 수행이 완료되기 전에 프로세스에게 주어진 할당 시간이 종료되면 프로세스는 준비 상태로 전이
			3. 실행 중인 프로세스에 입출력 처리가 필요하면 실행중인 프로세스는 대기상태로 전이
			4. CPU프로세스에 의해 수행
		* 대기 : 프로세스 입출력 처리가 필요하면 현재 실행중인 프로세스가 중단되고, 입출력 처리가 완료될 때까지 대기 하고 있는 상태
		* 종료 : 프로세스 실행이 끝나고 프로세스 할당이 해제된 상태
	4. **프로세스 상태 전이 관련 용어**
		1. DIspatch : 준비 상태에 대기하고 있는 프로세스 중 하나가 프로세스를 할당받아 실행 상태로 전이되는 과정
		2. Wake up : 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정
		3. Spooling : 입출력 장치의 공유 및 상대적으로 느린 입출력장치의 처리 속도를 보완하기 위해 입출력할 데이터를 직접 장치에 보내지 않고 나중에 한꺼번에 입출력하기 위해 디스크에 저장하는 과정
		4. Traffic Controller : 프로세스의 상태에 대한 조사와 통보를 담당
	5. **Thread**
		* 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아서 실행하는 프로세스 단위
		* 프로세스의 일부 특성을 가지고 있어 경량 프로세스라고도 함
		* 동일 프로세스 환경에서 독립적인 다중 수행 가능
		* 스레드 분류
			1. 사용자 수준의 스레드 : 사용자가 만든 라이브러리를 사용하여 운용하기 때문에 속도는 빠르지만 구현은 어렵
			2. 커널 수준의 스레드 : 운영체제의 커널에 의해 스레드를 운영하기 때문에 속도는 느리지만 구현이 쉬움
		* 스레드 사용의 장점
			1. 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진 가능
			2. HW, OS의 성능과 응용 프로그램의 처리율 향상
			3. 응용 프로그램의 응답시간을 단축
			4. 프로세스들 간의 통신이 향상
			5. 공통적으로 접근 가능한 기억장치를 효율적으로 통신

9. ### 스케줄링

	1. **스케줄링의 개요**

		* 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업
		* 프로세스가 생성되어 완료될 때까지 여러 종류의 스케줄링 과정을 거침
		* 그 종류에는 장기, 중기, 단기 스케줄링이 있다.
		* **Context Switch**
			1. 하나의 PS가 다른 PS로 CPU가 할당되는 과정에서 발생하는 것
			2. 새로운 PS에 CPU할당하기 위해 현재 CPU가 할당된 PS의 상태 정보 저장
			3. 새로운 PS의 상태 정보를 설정한 후 CPU를 할당하여 실행하도록 하는 작업

	2. **스케줄링의 목적**

		* **CPU나 자원의 효율적인 관리를 위해**

		1. 공정성 : 모든 PS에 공정하게 할당
		2. 처리율 증가 : 단위 시간당 PS 처리하는 비율 혹은 양을 증가
		3. CPU 이용률 증가 : CPU의 낭비 시간을 줄이고 CPU가 순수 프로세스를 실행하는데 사용되는 시간 비율 증가
		4. 우선순위 제도 : 우선순위가 높은 PS를 먼저 실행
		5. 오버헤드 최소화 : 어떤 처리를 위해 들어가는 간접적인 처리시간이나 메모리를 최소화
		6. 응답 시간 최소화
		7. 반환 시간 최소화
		8. 대기 시간 최소화
		9. 균형 있는 자원의 사용
		10. Dead lock 회피

	3. **프로세스 스케줄링의 기법**

		* **비선점 스케줄링**
			1. 강제 종료 불가능
			2. 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용 불가능
			3. PS가 CPU를 할당 받으면 완료까지 사용
			4. PS 응답 시간 예측이 용이
			5. 우선순위가 높은 작업이 기다리는 상황이 발생
			6. **FCFS, SJF, 우선순위 , HRN, 기한부 등의 알고리즘
		* **선점 알고리즘**
			1. 강제 종료 가능
			2. 우선순위가 높은 다른 PS가 CPU를 강제로 빼앗아 사용가능
			3. 우선순위가 높은 PS를 빠르게 처리 가능
			4. 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 적용
			5. 많은 오버헤드
			6. 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요
			7. Round Robin, SRT, 선점 우선순위, 다단계 큐 등의 알고리즘

10. ### 환경변수

	1. **환경변수의 개요**
		* 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임
	2. **WIndows 환경 변수**
		* Windows에서 환경 변수를 명령어나 스크립트에서 사용하기 위해서는 변수명 앞뒤에 %를 붙인다.
		* **대표적인거**
			1. HOMEPATH
			2. PATH
			3. TEMP
			4. USERNAME
			5. **SET** : 모든 환경 변수 보여주기 
	3. **UNIX / LINUX 환경 변수**
		* UNIX나 LINUX에서 환경 변수 사용하려면 $를 붙인다.
		* **대표적인거**
			1. DISPLAY
			2. HOME
			3. PATH
			4. PWD
			5. USER
			6. **env, printent, set** : 모든 환경 변수 보여주기

11. ## 운영체제 기본 명령어

	1. **운영체제 기본 명령어의 개요**
		* CLI : 키보드로 명령어를 입력하여 작업 수행하는 인터페이스
		* GUI : 마우스로 아이콘이나 메뉴 클릭하여 작업 수행 인터페이스
	2. **Windows 기본 명령어**
		1. DIR
		2. 