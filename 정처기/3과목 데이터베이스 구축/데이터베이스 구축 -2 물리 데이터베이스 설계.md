### 정보처리기사

---

1. **데이터 베이스 구축**
	1. **물리 데이터베이스 설계**
		1. [사전 조사 분석](#사전-조사-분석)
		2. [데이터베이스 저장 공간 설계](#데이터베이스-저장-공간-설계)
		3. [트랜잭션 분석/CRUD 분석](#트랜잭션-분석/CRUD-분석)
		4. [인덱스 설계](#인덱스-설계)
		5. [뷰 설계](#뷰-설계)
		6. [클러스터 설계](#클러스터-설계)
		7. [파티션 설계](#파티션-설계)
		8. [데이터베이스 용량 설계](#데이터베이스-용량-설계)
		9. [분산 데이터베이스 설계](#분산-데이터베이스-설계)
		10. [데이터베이스 이중화/서버 클러스터링](#데이터베이스-이중화/서버-클러스터링)
		11. [데이터베이스 보안-암호화](#데이터베이스-보안-암호화)
		12. [데이터베이스 보안-접근통제](#데이터베이스-보안-접근통제)
		13. [데이터베이스 백업](#데이터베이스-백업)
		14. [스토리지](#스토리지)
		15. [논리 데이터 모델의 물리 데이터 모델 변환](#논리-데이터-모델의-물리-데이터-모델-변환)
		16. [물리 데이터 모델 품질 검토](#물리-데이터-모델-품질-검토)

---

1. ### 사전 조사 분석

	1. **물리 데이터베이스 설계**

		* 논리적 구조로 표현된 논리적 데이터베이스를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변화하는 과정
		* **물리적 설계 단계에서 수행해야 하는 것**
			1. 저장 레코드의 양식 설계
			2. 레코드 집중의 분석 및 설계
			3. 접근 경로 설계
		* 물리적 데이터베이스 구조는 여러 가지 타입의 저장 레코드 집합이라 면에서 단순한 파일과는 다르다.
		* 물리적 설계 옵션
			1. 반응시간
			2. 공간 활용도
			3. 트랜잭션 처리량
2. **데이터 명명 규칙 파악**
		* 물리 데이터 모델에 적용해야하는 규칙
	* 데이터 표준화 및 논리 데이터베이스 설계의 결과물들을 통해 파악
		* 물리-논리 데이터베이스 설계 적용되는 명명규칙은 일관성 유지
		* 명명 규칙을 파악하기 위해선 도메인과 데이터 사전에 대한 지식 필요
		* **도메인** : Entity에 포함된 속성들의 데이터 타입, 크기 등을 표준화 규칙에 따라 일관성 있게 정의한 것을 의미한다. 
	3. **시스템 자원 파악**
		* 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소
		* 하드웨어 자원, 운영체제 및 DBMS의 버전, 파라미터 정보 등으로 구분
	4. **데이터베이스 관리 요소 파악**
		* DB 운영과 관련된 관리요소
		* DB 관리 요소를 파악한 후 이를 기반으로 시스템 조사 분식서를 작성
		* 시스템 조사 분석서를 기반으로 다음과 같은 요소들을 파악
			1. **DB 구조** : 구조에 따라 대응방식이 다름 
			2. **이중화 구성** : **문제 발생에 대비하여 동일한 DB 복제 관리**
			3. **분산 데이터베이스** : 물리적인 피해에 데이터 유실을 최소화할 수 있고 장애로 인한 유실 복구에 효과적
			4. **접근 제어/통제** : 접근 가능한 사용자의 권한 남용으로 인한 정보 유출 및 변조가 빈번하게 발생
			5. **DB암호화** : 데이터 암호화, 암호 키에 대한 인증 등을 통해 데이터 유출 시 데이터의 복호화를 어렵게 함
	
2. ### 데이터베이스 저장 공간 설계

	1. **Table**
		* 가장 기본 단위로써 행, 열로 구성됨
		* **논리 설계 단계의 Entity에 대응하는 객체**
		* 일반, 클러스터 인덱스, 파티셔닝, 외부, 임시 테이블이 있다.
	2. **일반 테이블**
		* 현재 사용되는 DBMS에서 표준 테이블로 사용되는 테이블
	3. **Cluster Index Table**
		* 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블
		* 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축
	4. **Partitioning Table**
		* 대용량의 테이블을 작은 논리적인 단위인 파티션으로 나눈 테이블
		* 대용량의 데이터를 효과적으로 관리할 수 있지만 파티션 키를 잘못 구성하면 성능 저하 등 역효과를 초래할 수 있음.
		* **방식에 따라 분할이 달라짐**
			1. **범위 분할** : 지정한 **열의 값을 기준으로 분할**
			2. **해시 분할** : **해시 함수를 적용한 결과 값에 따라 데이터 분할**
			3. **조합 분할** : **범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할**
	5. **외부 테이블**
		* 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부파일로 데이터베이스 내에 객체로 존재
		* 데이터 쉐어하우스 , ETL 등의 작업에 사용
	6. **Temporary Table**
		* 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
		* 절차적인 처리를 위해 임시로 사용
		* 저장된 데이터는 트랜잭션이 종료되면 삭제
	7. **Column**
		* 테이블의 열을 구성하는 요소로 데이터 타입과 길이 등으로 정의
		* 데이터 타입은 데이터의 일관성 유지를 위해 사용하는 가장 기본적인 것
		* 도메인을 정의한 경우 도메인에 따라 데이터의 타입과 길이가 정의
		* 두 칼럼을 비교하는 연산에서 두 칼럼의 데이터 타입이나 길이가 다르면 DBMS 내부적으로 데이터 타입 변화 후 비교 연산 수행
		* 참조 관계인 칼람들은 데이터 타입과 길이가 일치해야 함
	8. **Tablespace**
		* **테이블이 저장되는 논리적인 영역**으로 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장할 수 있음
		* **테이블을 저장하면 논리적으론 테이블스페이스 물리적으론 연관된 데이터 파일에 저장됨**
		* 테이블, 테이블스페이스, 데이터 파일로 나눠 관리하면 논리적 구성 물리적 구성에 종속되지 않아 투명성이 보장됨
		* **투명성** : 사실의 존재 여부를 염두에 두지 않아도 되는 성질
		* DB에 저장되는 내용에 따라 테이블, 인덱스, 임시 등의 용도로 구분하여 설계

3. ### 트랜잭션 및 CRUD 분석

	1. **트랜잭션의 정의**
		* 데이터베이스의 상태를 변환시키는 **하나의 논리적인 기능을 수행하기 위한 작업 또는 단위 또는 한꺼번에 수행되어야 할 일련의 연산들을 의미**
		* 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적인 단위
		* 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위
	2. **트랜잭션의 특성**
		1. **Atomicity** 
			* All or Nothing
			* DB에 반영되도록 완전히 완료 아니면 전혀 반영되지 않도록 복구되어야 함
			* 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
		2. **Consistency**
			* 문법을 일괄적으로 맞춰야 함
			* 트랜잭션을 성공적으로 완료하면 언제나 일관성 있는 DB 상태로 변환
			* 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후가 상태가 같아야 함
		3. **Isolation**
			* 하나의 트랜잭션 연산 중에는 다른 트랜잭션이 관여하면 안됨
			* 수행 중인 트랜잭션은 완전한 완료때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음
		4. **Durability**
			* 성공적으로 완료된 트랜잭션의 결과는 영구적으로 유지, 반영되어야 함
	3. **CRUD분석**
		* DB의 테이블에 변화를 주는 CRUD의 연산에 대해 **CRUD 매트릭스를 작성하여 분석하는 것**
		* 테이블에 발생되는 트랜잭션의 주기별 발생 횟수를 파악하고 연관된 테이블들을 분석하면 테이블에 저장되는 데이터의 양을 유추할 수 있음
		* **CRUD 매트릭스 표를 통해 작성하면 오류나 빠진부분 찾기 쉽다**
		* **C -> D -> U -> R **순서로 중요도 체크!
	4. **트랜잭션 분석**
		* CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하고 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB용량을 산정, DB 구조를 최적화하는 것
	5. **트랜잭션 분석서**
		* 단위 프로세스와 CRUD 매트릭스를 이용하여 작성
		* **구성 요소**
			1. 단위 프로세스 : 업무를 발생시키는 가장 작은 단위의 프로세스
			2. CRUD 연산 : 프로세스의 트랜잭션이 데이터베이스 테이블에 영향을 주는 4가지 연산
			3. 테이블명, 컬럼명
			4. 테이블 참조 횟수
			5. 트랜잭션 수
			6. 발생 주기

4. ### 인덱스 설계

	1. **인덱스의 개념**

		* 데이터 레코드를 빠르게 접근하기 위해 키값, 포인터 쌍으로 구성되는 데이터 구조
		* 책의 목차와 유사
		* 데이터가 저장된 물리적 구조와 밀접한 관계가 있음
		* 파일의 레코드에 대한 엑세스를 빠르게 수행할 수 있음
		* 인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 확인하는 Table Scan이 발생
		* 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는것이 효율적
		* **클러스터 인덱스** : 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
		* **Non 클러스트 인덱스** : 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않은 방식

	2. **트리 기반 인덱스**

		* 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것으로 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용

		1. **B 트리 인덱스**
			* 일반적으로 사용하는 인덱스 방식
			* 루트 노드에서 하위 노드로 키값의 크기를 비교하면서 데이터를 검색
			* 모든 리프 노드의 레벨은 같음
		2. **B+ 트리 인덱스**
			* 단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분
			* 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공
			* 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴
			* 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드 만을 이용한 순차 처리 가능

	3. **비트맵 인덱스**

		* 인덱스 칼럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
		* 키 값을 포함하는 **row**의 주소를 제공
		* 데이터가 Bit로 구성되어 있어 효율적인 논리 연산이 가능하고 저장공간이 작음

	4. **함수 기반 인덱스**

		* 칼럼의 값 대신 칼럼의 특정 함수나 수식을 적용하여 산출된 값을 사용
		* B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용
		* 데이터를 입력하거나 수정할 때 함수를 적용하기 때문에 부하가 발생할 수 있음
		* 사용자 정의 함수를 사용했을 경우 시스템 함수보다 부하가 더 크다.
		* 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용

	5. **비트맵 조인 인덱스**

		* 다수의 조인된 객체로 구성된 인덱스
		* 비트맵 조인 인덱스는 비트맵 인덱스의 **물리적 구조가 동일하다**

	6. **도메인 인덱스**

		* 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로 **확장형 인덱스**라고도 함

	7. **인덱스 설계 순서**

		1. 인덱스의 대상 테이블이나 칼럼 등을 선정
		2. 인덱스의 효율성을 검토하여 인덱스 최적화 수행
		3. 인덱스 정의서 작성

	8. **인덱스 대상 테이블 선정 기준**

		* **Multi Block Read 수에 따라 판단**
		* **테이블 엑세스 시 메모리에 한 번에 읽어 들일 수 있는 블록의 수를 뜻한다.**
		* 랜덤 엑세스가 빈번한 테이블
		* 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
		* 다른 테이블과 순차적 조인이 발생되는 테이블

5. ### 뷰 설계

	1. **뷰의 개요**
		* 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본테이블로부터 유도된 이름을 가지는 가상 테이블
		* 물리적으로 존재하지는 않지만 사용자에게는 있는 것처럼 간주됨
		* 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용
		* 조인문의 최소화로 사용자 편의성을 최대화함
	2. **뷰의 특징**
		* 기본 테이블과 같은 형태의 구조를 사용하고 조작도 기본 테이블과 거의 같음
		* 가상테이블이기 때문에 물리적으로 구현되어 있지 않음
		* 데이터의 논리적 독립성을 제공할 수 있음
		* 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
		* 뷰를 통해서만 데이터에 접근하게 되면 뷰에 나타나지 않은 데이터를 안전하게 보호하는 효율적인 기법을 사용할 수 있음
		* 뷰가 정의된 기본 테이블이나 뷰를 삭제 시 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제
	3. **뷰의 장단점**
		* **장점**
			1. 논리적 데이터 독립성 제공
			2. 동일 데이터에 대해 동시에 여러 사용자의 상이한 요구를 지원
			3. 사용자의 데이터 관리가 용이
			4. 접근 제어를 통한 자동 보안 제공
		* **단점**
			1. 독립적인 인덱스를 가질 수 없음
			2. 뷰의 정의 변경 불가
			3. 뷰로 구성된 내용에 대해 insert, delete, update 연산에 제약이 따름
	4. **뷰 설계 순서**
		1. 대상 테이블 선정
		2. 대상 칼럼 선정
		3. 정의서 작성
	5. **뷰 설계 시 고려사항**
		* 테이블 구조가 단순화될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성
		* 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수 있으므로 사용할 데이터를 다양한 관점에서 제시
		* 데이터의 보안을 유지하며 설계

6. ### 클러스터 설계

	1. **클러스터의 개요**
		* 데이터 저장 시 데이터 엑세스 효율을 향상시키기 위해 동일한 성격의 데이터를 데이터 블록에 저장하는 물리적 저장 방법
		* 클러스터링키로 지정된 칼럼 값의 순서대로 저장되고 여러 개의 테이블이 하나의 클러스터에 저장
	2. **클러스터의 특징**
		* 데이터 조회 속도를 향상시키지만 데이터 입력 수정 삭제에 대한 성능은 저하시킴
		* 데이터 분포도가 넓을수록 유리
		* 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 지양
		* **파티셔닝 된 테이블에는 적용할 수 없음**
	3. **클러스터 대상 테이블**
		* 분포도가 넓은 테이블
		* 대량의 범위를 자주 조회하는 테이블
		* 입력, 수정, 삭제가 자주 발생하지 않는 테이블
		* 자주 조인되어 사용되는 테이블
		* order by, group by, union이 빈번한 테이블

7. ### 파티션 설계

	1. **파티션의 개요**

		* 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것
		* 대용량 DB의 경우 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방지하고 데이터 관리가 용이함
		* 데이터 처리는 테이블 단위, 데이터 저장은 파티션 별로 수행

	2. **파티션의 장단점**

		* **장점**
			1. 데이터 접근 시 엑세스 범위를 줄여 퀄 성능 향상 
			2. 데이터가 분산되어 저장되므로 디스크 성능 향상
			3. 파티션별로 백업 및 복구를 수행하므로 속도 향상
			4. 시스템 장애 시 데이터 손상 정도 최소화
			5. 데이터 가용성 향상
			6. 파티션 단위로 입출력 분산
		* **단점**
			1. 하나의 테이블을 세분화하여 관리하기 때문에 세심한 관리가 요구됨
			2. 테이블 간 조인에 대한 비용 증가
			3. 용량이 작은 테이블에 파티셔닝을 수행하면 성능이 저하됨

	3. **파티션의 종류**

		1. **범위 분할** : 지정한 열의 값을 기준으로 분할
		2. **해시 분할** : 해시 함수를 적용한 결과 값에 따라 데이터를 분할
		3. **조합 분할** : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할

	4. **파티션 키 선정 시 고려사항**

		* 파티션 키는 테이블 접근 유형에 따라 파티셔닝이 이루어지도록 선정
		* 데이터 관리의 용이성을 위해 이력성 데이터는 파티션 생성 주기와 소멸 주기를 일치시켜야 함
		* 매일 생성되는 날짜 칼럼, 백업의 기준이 되는 날짜 칼럼, 파티션 간 이동이 없는 칼럼, I/O 병목을 줄일 수 있는 데이터 분포가 양호한 칼럼 등을 파티션 키로 선정

	5. **인덱스 파티션**

		* 파티션 된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것

		* 파티션 된 테이블의 종속 여부에 따른 구분

			1. Local Partitioned Index : 테이블 파티션과 인덱스 파티션이 1대1 대응되도록 파티셔닝 함
			2. Global : 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티셔닝 함

			* **Local이 Global보다 관리가 용이함**

		* **인덱스 파티션 키 칼럼의 위치에 따른 구분**

			1. Prefixed Partitoned Index : 인덱스 파티션 키와 인덱스 첫 번째 칼럼이 같음
			2. Non-Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 칼럼이 다름

8. ### 데이터베이스 용량 설계

	1. **데이터베이스 용량 설계**
		* 데이터가 테이블에 저장될 공간을 정의
		* 테이블에 저장할 데이터양, 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영
	2. **데이터베이스 용량 설계의 목적**
		* 디스크의 저장공간을 효과적으로 사용하고 확장성 가용성을 높임
		* 디스크의 입출력 부하를 분산시키고 채널의 병목현상 최소화
		* 디스크에 대한 입출력 경합이 최소화되도록 설계함으로써 데이터 접근성이 향상
		* 데이터베이스에 생성되는 오브젝트의 익스텐트 발생을 최소화하여 성능을 향상
		* 테이블과 인덱스에 적합한 저장 옵션을 지정
		* 데이터 접근성을 향상시키는 설계 방법
			1. 테이블의 테이블스페이스와 인덱스의 테이블스페이르를 분리하여 구성
			2. 테이블스페이스와 임시 테이블스페이스를 분리하여 구성
			3. 테이블을 마스터 테이블과 트랜잭션 테이블로 분류
	3. **데이터베이스 용량 분석 절차**
		* 데이터 예상 건수, 로우 길이, 보존 기간, 증가율 등 기초 자료를 수집하여 용량 분석
		* 분석된 자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량을 산정
		* 테이블과 인덱스의 테이블스페이스 용량을 산정
		* 데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량 산정

9. ### 분산 데이터베이스 설계

	1. **분산 데이터베이스 정의**
		* 논리적인 하나의 시스템이지만 물리적으로는 네트워크로 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스
		* 데이터베이스를 네트워크를 이용해 나눠놓음
	2. **분산 데이터베이스의 구성 요소**
		1. **분산 처리기** : 지리적으로 분산되어 있는 컴퓨터 시스템
		2. **분산 데이터베이스** : 지리적으로 분산되어 있는 데이터베이스
		3. **통신 네트워크** : 분산 처리기들을 네트워크로 연결하여 하나의 시스템처럼 동작할 수 있도록 하는 통신 네트워크
	3. **분산 데이터베이스 설계 시 고려사항**
		* 작업 부하의 노드별 분산 정책
		* 지역의 자치성 보장
		* 데이터의 일관성
		* 사이트나 회선의 고장으로부터의 회복 기능
		* 통신 네트워크를 통한 원격 접속
	4. **분산 데이터베이스의 목표**
		1. 위치 투명성 : 접근하려는 데이터베이스의 실제 위치를 알 필요 없이 논리적인 명칭만으로 접근 가능
		2. 중복 투명성 : 동일 데이터가 여러 곳에 중복되어 있어도 사용자는 하나의 데이터만 존재하는 것 처럼 사용 가능
		3. 병행 투명성 : 분산 데이터베이스와 관련된 다수 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향 받지 않음
		4. 장애 투명성 : 트랜잭션 , DBMS, 네트워크, 컴퓨터 등에 장애에도 트랜잭션을 정확하게 처리
		5. 투명성 : 사실 존재 여부를 염두에 두지 않아도 되는 성질 
	5. **분산 데이터 베이스의 장단점**
		* **장점**
			1. 지역 자치성이 높음
			2. 자료의 공유성 향상
			3. 분산 제어 기능
			4. 시스템 성능 향상
			5. 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음
			6. 효용성과 융통성이 높음
			7. 신뢰성 및 가용성이 좋음
			8. 점진적 시스템 용량 확장 용이
		* **단점**
			1. DBMS 수행할 기능이 복잡
			2. DB 설계가 어려움
			3. 소프트웨어 개발 비용 증가
			4. 처리 비용 증가
			5. 잠재적 오류 증가
	6. **분산 데이터베이스 설계**
		* 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하는 것이 목적
		* 전역 관계망을 논리적 측면에서 소규모 단위로 분할, 분할된 결과를 복수의 노드에 할당
		* 분산 설계 방법에는 테이블 위치 분산, 분할, 할당이 있음
	7. **테이블 위치 분산**
		* 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치
		* 테이블의 구조를 변경시키지 않고 다른 데이터테이블의 테이블과 중복되지 않게 배치
	8. **분할**
		* 테이블의 데이터 분할하여 분산
		* **분할 규칙**
			1. 완전성 : 전체 데이터를 대상으로 분할해야 한다.
			2. 재구성 : 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성할 수 있어야 한다.
			3. 상호 중첩 배제 : 분할된 데이터는 서로 다른 분할의 항목에 속하지 않아야 한다.
		* **분할 방법**
			1. 수평, 행 단위 
			2. 수직, 열 단위
	9. **할당 Allocation**
		* 동일한 분할을 여러 개의 서버에 생성하는 분산 방법
		* 비중복 할당 방식 : 최적의 노드를 선택해서 분산 데이터베이스의 단일 노드에서만 분할이 존재
		* 중복 할당 방식 : 동일한 테이블을 다른 서버에 복제하는 방식

10. ### 데이터베이스 이중화 / 서버 클러스터링

	1. **데이터베이스 이중화**

		* 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것
		* 하나 이상의 데이터베이스가 항상 같은 상태를 유지
		* 데이터베이스가 문제가 생기면 즉시 해결 가능
		* 사용자가 작업을 수행하면 이중화 시스템에 연결된 다른 데이터베이스도 동일하게 적용
		* 애플리케이션을 여러 개의 데이터베이스로 분산시켜 처리해 데이터베이스의 부하를 감소

	2. **데이터베이스 이중화의 분류**

		* 내용 전달 방식에 따른 분류

		1. **Eager 기법** : 트랜잭션 수행 중 데이터 변경 발생시 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용을 즉시 적용
		2. **Lazy 기법** : 트랜잭션 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터 베이스에 전달하여 데이터 베이스마다 새로운 트랜잭션이 수행되는 것으로 간주 

	3. **데이터베이스 이중화 구성 방법**

		* **Active-Standby 방법**
			1. 한 DB가 서비스 시 다른 DB는 대기
			2. 활성 DB에 장애 발생 시 대기 중이었던 DB가 모든 서비스를 대신 수행
			3. 구성 방법 및 관리가 쉬워 많은 기업에서 사용
		* **Active-Active**
			1. 두 개의 DB가 서로 다른 서비스를 제공
			2. 한쪽 DB에 장애 발생 시 다른 DB가 서비스를 제공
			3. 두 DB가 모두 처리를 해 처리율이 높지만 구성 방법 및 설정은 복잡

	4. **Clustering**

		* 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
		* 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공
		* **고가용성** : 시스템을 오랜 시간 동안 계속해서 정상적으로 운영이 가능한 성질
		* **병렬 처리 클러스터링** : 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리
		* **고가용성 클러스티렁** : 하나의 서버에 장애가 발생 시 다른 서버가 받아서 처리하여 서비스 중단을 방지하는 방식

11. ### 데이터베이스 보안/암호화

	1. **데이터베이스 보안의 개요**
		* 데이터베이스의 일부분 또는 전체에 권한이 없는 사용자가 엑세스 하는 것을 금지하기 위해 사용되는 기술
	2. **암호화 / 복호화**
	3. **개인키 / 공개키 암호 방식**
		* **개인키**
			1. 대칭키 암호, 단일키 기법이라고 한다.
			2. 비밀키를 노출 안시키고 권한이 있는 사람만 가지고 있다.
			3. 전위 기법, 대체 기법, 대수 기법, 합성 기법 (DES)
		* **공개키**
			1. 암호화 키와 복호화 키 따로
			2. RSA

12. ### 데이터베이스 보안/접근통제

	1. **접근통제**

		* 데이터가 저장된 객체와 사용하려는 주체 사이의 정보 흐름을 제한
		* 데이터에 대해 통제를 함으로써 자원의 불법적인 접근 및 파괴를 예방
		* **Discretionary Access Control**
			1. 데이터에 접근하는 사용자의 신원에 따라 접근 권한 부여
			2. 통제 권한이 주체에 있어 접근통제 권한을 주체가 지정하고 제어
			3. 객체를 생성한 사용자가 객체에 대한 모든 권한을 부여 받고 다른 사용자에게 허가 가능
			4. SQL 명령어로는 **GRANT, REVOKE**이 있음
		* **Mandatory Access Control**
			1. 주체와 객체의 등급을 비교하여 접근 권한을 부여
			2. 제 3자가 접근통제 권한 지정
			3. 객체별로 보안 등급을 부여할 수 있으며 사용자별로 인가 등급을 부여할 수 있음
			4. 주체의 보안 등급이 자신의 보안등급보다 **높으면 다 불가능, 같으면 다 가능, 낮으면 읽기만 가능**

	2. **접근통제 정책**

		* 어떤 주체가 언제 어디서 어떤 객체에게 어떤 행위에 대한 허용 여부를 정의하는 것

		* **신분 기반 정책**

			1. **Individual-Based-Policy** : 최소 권한 정책, 단일 주체에게 하나의 객체에 대한 허가를 부여
			2. **Group-Based-Policy** : 복수 주체에 대한 허가를 부여

		* **규칙 기반 정책**

			* **주체가 갖는 권한에 근거하여 객체의 접근을 제한**

			1. **MLP ( Multi-level-Policy)** : 사용자 및 객체별로 지정된 기밀 분류에 따른 정책
			2. **CBP ( Compartment-Based-Policy)** : 집단별로 지정된 기밀 허가에 따른 정책

		* **역할 기반 정책**

			* 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한

	3. **접근통제 메커니즘**

		1. **Access Control List** : 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지 기록한 목록이다.
		2. **Capability List** : 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록이다
		3. **Security Label** : 주체나 객체 등에 부여된 보안 속성의 집합으로, 등급을 기반으로 접근 승인 여부가 결정된다.
		4. **패스워드** : 주체가 자신임을 증명할 때 사용하는 인증 방법이다.
		5. **암호화** : 데이터를 보낼 때 지정된 수신자 이외에는 내용을 알 수 없도록 평문을 암호문으로 변환하는 것으로, 무단 도용을 방지하기 위해 주로 사용된다.

	4. **접근통제 보안 모델**

		* 보안 정책을 구현하기 위해 정형화된 모델

		1. **기밀성 모델**
			* 군사적인 목적으로 개발된 최초의 수학적 모델로 기밀성 보장이 최우선이다.
		2. **무결성 모델**
			* 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델
			* 데이터 일관성 유지에 중점을 두어 개발
		3. **접근통제 모델**
			* 접근통제 매커니즘을 보안 모델로 발전시킨 것
			* 접근통제 모델 : 임의적인 접근 통제를 관리하기 위한 모델로 행은 주체 열은 객체를 의미
			* R, W, ALL

	5. **접근통제 조건**

		* 접근통제 매커니즘의 취약점을 보안하기 위해 접근 통제 정책에 부가하여 적용할 수 있는 조건

		1. **값 종속 통제** : 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우
		2. **다중 사용자 통제** : 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우
		3. **콘텍스트 기반 통제** : 특정 시간, 네트워크 주소, 접근 경로, 인증 경로 등에 근거하여 접근을 제어하는 방식

	6. **감사 추적**

		* 사용자나 애플리케이션의 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 행위
		* 오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용

13. ### 데이터베이스 백업

	1. **데이터베이스 백업**

		* 전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업

	2. **데이터베이스 장애 유형**

		1. 사용자 실수 : 사용자의 실수로 인한 오류
		2. 미디어 장애 : 하드웨어 장애나 데이터가 파손된 경우
		3. 구문 장애 : 프로그램 오류나 사용 공간의 부족으로 발생하는 장애
		4. 사용자 프로세스 장애 : 프로그램이 비정상적으로 종료되거나 네트워크 이상으로 세션이 종료되어 발생하는 장애
		5. 인스턴스 장애 : 하드웨어 장애, 정전, 시스템 파일 파손 등 비정상적 요인으로 메모리나 데이터베이스 서버의 프로세스가 중단된 경우

	3. **로그 파일**

		* 데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 기록한 파일
		* 로그 파일을 기반으로 과거 상태로 **UNDO**시키거나 현재 상태로 **REDO**시켜 데이터베이스 상태를 일관성 있게 유지

	4. **데이터베이스 복구 알고리즘**

		* 동기적/비동기적 갱신에 따라 분류

		1. REDO : 비동기적으로 갱신하는 경우
		2. UNDO : 동기적으로 하는 경우
		3. REDO / UNDO : 동기/비동기적 하는 경우
		4. NO REDU / UNDO : 동기적으로 저장 매체에 기록하지만 데이터베이스아는 다른 영역에 기록한 경우

	5. **백업 종류**

		* 물리 백업 : 데이터베이스 파일을 백업하는 방법
		* 논리 백업 : 데이터베이스 내의 논리적 객체들을 백업하는 방법 

14. ### 스토리지

	1. **스토리지의 개요**
		* 스토리지는 단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술이다.
		* DAS, NAS, SAN이 있다.
	2. **DAS (Direct Attached Stroage)**
		* 서버와 저장장치를 전용 케이블로 직접 연결하는 방식
		* 서버에서 저장장치를 관리
		* 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉬움
		* 다른 서버에서 스토리지에 접근하여 사용 불가
	3. **NAS ( Network Attachked Storage)**
		* 서버와 저장장치를 네트워크를 통해 연결하는 방식
		* 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리
		* DAS에 비해 확장성 및 유연성이 좋음
		* 서버들이 자유롭게 스토리지에 접근하여 파일 공유
	4. **SAN ( Storage Area Network)**
		* DAS의 빠른처리와 NAS의 파일 공유 장점을 혼합한 방식
		* 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성
		* 파이버 채널 스위치를 이용하여 네트워크 구성
		* **파이버 채널** : 장치간 데이터 전송 속도를 기가바이트로 높이기 위한 네트워크 기술
		* 서버나 저장장치를 광케이블로 연결하므로 처리 속도가 빠름
		* 서버들이 저장장치 및 파일을 자유롭게 공유

16. ### 논리 데이터 모델의 물리 데이터 모델 변환

     1. **테이블**

     	* 데이터를 저장하는 DB가장 기본적인 오브젝트

     2. **Entity -> Table**

     	* 논리 데이터 모델에서 정의된 Entity를 물리 데이터 모델의 테이블로 변환
     	* **테이블 목록 정의서** : 전체 테이블을 목록으로 요약 관리하는 문서로, 테이블 목록이라고도 한다.
     	* 변환시 고려사항
     		1. Entity와 Table은 이름이 같도록 권고
     		2. 영문명
     		3. 메타에 등록된 단어를 사용하여 명명

     3. **슈퍼타입/서브타입을 테이블로 변환**

       * 슈퍼타입과 서브타입은 논리 데이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 때는 테이블로 변환

       1. **슈퍼타입 기준**

       	* **장점**
          
            1. 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만듦
            2. 데이터의 엑세스가 상대적 용이
            3. 뷰를 이용하여 각각의 서브타입만을 엑세스 하거나 수정할 수 있음
       	  4. SQL문장 구성이 단순
       	* **단점**
       	  1. 디스크 저장 공간이 증가
         2. 인덱스 효율이 떨어진다.
       2. **서브타입 기준**
       	* **장점**
       		1. 선택 사양이 명확한 경우 유리
       		2. 처리때마다 유형을 구분할 필요가 없다
       		3. 전체 테이블 스캔시 유리
       	* **단점**
       		1. 수행 속도 감소
       		2. SQL 통합이 어렵다
       		3. 부분 범위에 대한 처리가 곤란해진다
       		4. 여러 테이블을 통합한 뷰는 조회만 가능하다
       		5. UID 의 유지 관리가 어렵다.
       3. **개별타입 기준 테이블 변환**
       	* **슈퍼타입과 서브타입의 1 : 1 관계가 형성된다**
       	* 저장공간이 상대적으로 작음

     4. **속성을 칼럼으로 변환**

     	* 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환

     	* **일반 속성 변환**
     		1. 엔티티의 속성을 테이블의 각각의 컬럼으로 변환
     		2. 칼럼명은 SQL 예약어 사용을 피하고 가능한 짧게 지정
     	* **관계를 외래키로 변환**
     		1. 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 기본키로 변환
     		2. 

