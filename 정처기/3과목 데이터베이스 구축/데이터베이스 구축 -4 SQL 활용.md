### 정보처리기사

---

1. **데이터 베이스 구축**
	1. **SQL 활용**
		1. [프로시저](#프로시저)
		2. [트리거](#트리거)
		3. [사용자 정의 함수](#사용자-정의-함수)
		4. [DBMS 접속 기술](#DBMS-접속-기술)
		5. [SQL 테스트](#SQL-테스트)
		6. [ORM](#ORM)
		7. [쿼리 성능 최적화](#쿼리-성능-최적화)

---

1. ### 프로시저

	1. **프로시저의 개요**

		* 절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어
		* 호출을 통해 실행되어 미리 저장해놓은 SQL작업 수행
		* 여러 프로그램에서 호출하여 사용 가능
		* 데이터베이스에 저장되어 수행되기 때문에 스토어드 프로시저라고도 함
		* 시스테므이 일일 마감 작업, 일괄 작업 등에 사용

	2. **프로시저의 구성**

		* declare : 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부
		* begin / end : 프로시저의 시작과 종료를 의미
		* control : 조건문 또는 반복문이 삽입되어 순차적으로 처리
		* Exception : begin ~ end 안의 구문 실행 시 예외 처리
		* Transaction : 수행된 데이터 작업들을 DB에 저장할지 취소할지 결정

	3. **프로시저 생성**

		```sql
		create [or replace] procedure 프로시저명(파라미터)
		[지역변수 선언]
		begin
			프로시저 body;
		end;
		```

		* or replace : 동일한 이름 존재시 기존의 프로시저를 **대체한다**
		* 파라미터
			1. IN : 호출 프로그램이 프로시저에 값을 전달할때 사용
			2. OUT : 프로시저가 호출 프로그램에게 값을 전달할 때 사용
			3. INOUT : 호출 프로그램이 프로시저에게 값을 전달하고, 프로시저 실행 후 호출 프로그램에게 값을 반환할 때 지정
			4. 매개변수명 : 호출 프로그램으로부터 전달받은 값을 저장할 변수의 이름을 지정
			5. 자료형 : 변수의 자료형을 지정 
		* **프로시저 BODY**
			1. 프로시저의 코드를 기록
			2. begin과 end사이에 적어도 하나의 sql이 존재해야 한다.

		```sql
		create or replace procedure emp_change_s(i_사원번호 in int)
		is
		begin
			update 급여 set 지급방식 = 's' where 사원번호 =i_사원번호;
			exception
				when program_error then
					rollback;
			commit;
		end;
		```

	4. **프로시저 실행**

		```sql
		execute 프로시저명;
		exec 프로시저명;
		call 프로시저명;
		
		excute emp_change_s(32)
		```

		* 형식으로 프로시저를 실행하고

		```sql
		drop procedure 프로시저명;
		```

		* 프로시저 제거 명령어

2. ### 트리거

	1. **트리거의 개요**

		* 데이터베이스 시스템에 데이터의 CRUD 이벤트 발생시 관련 작업이 자동으로 수행되는 절차형 sql
		* 데이터베이스에 저장
		* 데이터 변경 및 무결성 유지
		* 로그 메시지 출력 등의 목적
		* DCL 사용 불가능 + 포함된 프로시저나 함수도 불가능
		* 트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향을 미침

	2. **트리거의 구성**

		1. declare : (필수) 선언부
		2. event : (필수) 조건명시
		3. begin / end
		4. control : (필수) 조건문 또는 반복문 
		5. sql : DML
		6. exception 

	3. **트리거의 생성**

		```sql
		create or replace trigger 트리거명 [동작시기 옵션][동작 옵션] on 테이블명
		referencing [new|old] as 테이블명
		for each row
		[when 조건식]
		begin
			트리거 body;
		end;
		```

		* 동작 시기 옵션 : 트리거가 실행될 때를 지정
			1. AFTER
			2. BEFORE
			3. **기준은 테이블의 변경 전후**
		* 동작 옵션 : 트리거가 실행되게 할 작업의 종류를 지정
			1. insert
			2. delete
			3. update
		* NEW | OLD : 트리거가 적용될 테이블의 별칭을 지정
			1. NEW : 추가되거나 수정에 참여할 튜플들의 집합을 의미
			2. OLD : 수정되거나 삭제 전 대상이 되는 튜플들의 집합을 의미
		* FOR EACH ROW : 각 튜플마다 적용할 튜플의 조건을 지정
		* WHEN 조건식 : 트리거를 적용할 튜플의 조건을 지정

		```SQL
		create trigger 학년정보_tri before insert on 학생
		referencing new as new_table
		for each row
		when( new_table.학년 is null)
		begin
			:new_table.학년 :='신입생';
		end;
		```

	4. **트리거의 제거**

		* 트리거를 제거하기 위해서는 drop trigger 명령어를 사용한다.

3. ### 사용자 정의 함수

	1. **사용자 정의 함수의 개요**

		* 프로시저와 유사하게 sql을 사용하여 일련의 작업을 연속적으로 처리하여 종료 시 처리 결과를 단일 값으로 반환하는 절차형 sql
		* 데이터베이스에 저장되어 DML문의 호출에 의해 실행
		* 예약어 return을 통해 값이 반환되기 때문에 출력 파라미터가 없음
		* 테이블 조작은 할 수 없고 select을 통해 검색만 가능
		* **프로시저를 호출하여 사용 가능**

	2. **사용자 정의 함수의 구성**

		1. 위에랑 거의 똑같음
		2. return : 호출 프로그램에 반환할 값이나 변수 정의

	3. **사용자 정의 함수 생성**

		```sql
		create or replace function 사용자 정의 함수명(파라미터)
		[지역변수 선언]
		begin
			사용자 정의 함수 body;
			return 반환값;
		end;
		```

		```sql
		create function Get_s_성별(i_성별코드 IN INT)
		return varchar2
		is
		begin
			if(i_성별코드) then
				return '남자';
			else
				return '여자';
			end if;
		end;
		```

	4. **사용자 정의 함수 실행**

		* 사용자 정의 함수는 DML에서 속석명이나 값이 놓일 자리를 대체하여 사용된다.

		```sql
		select 사용자 정의 함수명 from table;
		insert into table values(함수)
		delete from table where 속성명 = 함수;
		update table set 속성명 = 함수;
		# 삭제
		drop function 함수명;
		```

4. ### DBMS 접속 기술

	1. **DBMS 접속의 개요**

		* 사용자가 데이터를 접속하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것
		* 응용 시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달
		* **웹 응용 시스템은 웹 서버와 웹 애플리케이션 서버로 구성**
		* **사용자 <-> 웹 서버 <-> WAS <-> DBMS**

	2. **DBMS 접속 기술**

		* DBMS에 접근하기 위해 사용하는 API 또는 프레임워크를 의미

		1. **API**
			* 응용 프로그램 개발 시 운영 체제나 DBMS 등을 이용할 수 있도록 규칙 등에 대해 정의해 놓은 인터페이스
		2. **JDBC**
			* JAVA 언어
			* 썬 마이크로시스템
			* JAVA SE에 포함되어 있고
			* 접속시 DBMS 드라이버 필요
		3. **ODBC**
			* 개발 언어와 상관 없음
			* 마이크로소프트에서 출시
			* 다양한 디비 접근 가능
		4. **MyBatis**
			* JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈소스 접속 프레임워크
			* SQL문장을 분리하여 XML 파일을 만들고 Mapping을 통해 SQL을 실행
			* SQL을 거의 그대로 사용할수 있어서 국내에 적합
		5. **Dynamic SQL**
			* 개발 언어에 삽입되는 SQL 코드를 문자열 변수에 넣어 처리하는 것
			* 조건에 따라 SQL 구문을 동적으로 변경하여 처리 가능
			* **NVL 함수를 사용할 필요가 없음**
			* 응용 프로그램 수행 시 SQL이 변형될 수 있어 프리컴파일할 때 구문 분석, 접근 권한 확인 등을 할 수 없음
			* **NVL (A,B)** -> A가 NULL이면 B리턴 아니면 A리턴 
			* **프리컴파일** : 고급언어를 기계어로 번역하는 컴파일 전에 수행하는 작업으로 필요한 라이브러리를 불러오거나 코드에 삽입된 SQL문을 DB와 연결하는 작업 수행

5. ### SQL 테스트

	1. **SQL 테스트의 개요**

		* SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증하는 과정
		* 단문 SQL은 코드를 직접 실행한 후 결과를 확인
		* 절차형 SQL은 테스트 전에 생성을 통해 구문 오류나 참조 오류의 존재 여부 확인
		* 정상적으로 생성된 절차형 SQL은 디버깅을 통해 로직을 검증하고 결과를 통해 최종 확인

	2. **단문 SQL 테스트**

		* DDL, DML, DCL이 포함되어 있는 SQL과 TCL을 직접 실행하여 테스트
		* DESCRIBE 명령어로 상태정보 확인 가능

	3. **절차형 SQL 테스트**

		* 프로시저, 사용자 정의함수, 트리거 등은 디버깅을 통해 기능의 적합성 여부 검증, 실행을 통해 결과 확인하는 테스트 수행
		* **SHOW 명령어를 통해 오류 확인**

		```SQL
		show errors;
		```

6. ### ORM

	1. **Ojbect Relationship Mapping의 개요**
		* 객체지향 프로그래밍의 객체와 관계형 데이터베이스의 데이터를 연결하는 기술
		* 객체지향 프로그래밍에서 사용할 수 있는 가상의 객체지향 데이터베이스를 만들어 프로그래밍 코드와 데이터 연결
		* 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수가 용이
		* SQL 코드를 직접사용하지 않기 때문에 직관적이고 간단하게 데이터 조작 가능
	2. **ORM 프레임워크**
		* ORM을 구현하기 위한 구조와 구현을 위해 필요한 여러 기능들을 제공하는 소프트웨어
		* JAVA : JPA, Hibernate, EclipseLink
		* C++ : ODB, QxOrm
		* Python : Django, strom
		* IOS : DatabaseObjects, Core Data
		* NET : NHibernate, DatabseObjects, Dapper
		* PHP : Doctrine, Propel, RedBean 
	3. **ORM의 한계**
		* **프레임워크가 자동으로 작성하기 때문에 의도대로 작성되었는지 확인할 필요가 있다**
		* 객체지향적 사용을 고려, 설계한 데이터베이스가 아닌 경우 프로젝트가 크고 복잡할수록 ORM기술을 적용하기 어려움
		* 기존의 기업들은 ORM을 고려 안해놔서 바꾸기 시간과 노력이 든다.

7. ### 쿼리 성능 최적화

	1. **쿼리 성능 최적화의 개요**

		* 데이터 입출력 애플리케이션의 성능 향상을 위한 sql코드를 최적화

		* 최적화 전 APM을 사용하여 최적화할 쿼리 선정

			1. REO : 규칙 기반 옵티마이저

			2. CBO : 비용 기반 옵티마이저

				|             |                 RBO                 |                 CBO                  |
				| :---------: | :---------------------------------: | :----------------------------------: |
				| 최적화 기준 |       규칙에 정의된 우선순위        |             엑세시 비용              |
				|  성능 기준  |         개발자의 sql숙련도          |        옵티마이저의 예측 성능        |
				|    특징     |        실행 계획 예측이 쉬움        | 성능 통계치 정보 활용, 예측이 복잡합 |
				|  고려사항   | 개발자의 규칙 이해도, 규칙의 효율성 |       비용 산출 공식의 정확성        |

	2. **실행 계획**

		* DBMS의 옵티마이저가 수립한 SQL 코드의 실행 절차와 방법을 의미
		* **EXPLAIN** 명령어를 통해 확인
		* 그래픽이나 텍스트로 표현
		* 요구사항을 처리하기 위한 연산 순서가 적혀있고 연산에는 조인, 테이블 검색, 필터, 정렬 등이 있음

	3. **쿼리 성능 최적화**

		* 실행 계획에 표시된 연산 순서, 조인 방식, 테이블 조회 방법 등을 참고하여 SQL문이 더 빠르고 효율적으로 작동하도록 코드와 인덱스를 재구성
		* SQL 코드 재구성
			1. where 절을 추가하여 일부 레코드만 조회
			2. where 절에 연산자 사용자제
			3. 특정 데이터 확인 시 IN 보다는 EXIST사용
			4. 힌트를 활용하여 실행 계획의 엑세스 경로 및 조인 순서 변경
		* **인덱스 재구성**
			1. SQL코드에서 조회되는 속성과 조건들을 고려하여 인덱스 구성
			2. 인덱스를 추가하거나 기존 인덱스의 열 순서 변경
			3. 단일 인덱스로 쓰거나 수정 없이 읽기로만 사용되는 경우 Index Organized Table로 구성

		