### 정보처리기사

---

3. **데이터 입출력 구현**
	1. [데이터 모델의 개념](#데이터-모델의-개념)
	2. [이상/함수적 종속/정규화](#이상/함수적-종속/정규화)
	3. [논리 데이터 모델의 물리 데이터 모델로 변환](#논리-데이터-모델의-물리-데이터-모델로-변환)
	4. [반정규화](#반정규화)
	5. [인덱스 설계](#인덱스-설계)
	6. [뷰 설계](#뷰-설계)
	7. [클러스터 설계](#클러스터-설계)
	8. [파티션 설계](#파티션-설계)
	9. [데이터베이스 용량 설계](#데이터베이스-용량-설계)

---

1. ### 데이터 모델의 개념

	1. **데이터 모델의 정의**
		* **현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형이다.**
		* **데이터 모델 구성 요소**
			1. 개체
			2. 속성
			3. 관계
		* **데이터 모델 종류**
			1. 개념적 데이터 모델
			2. 논리적 데이터 모델
			3. 물리적 데이터 모델
		* **데이터 모델에 표시할 요소**
			1. 구성
			2. 연산
			3. 제약
	2. **데이터 모델의 구성 요소**
		1. **개체** : 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체이다
		2. **속성** : 데이터의 가장 작은 논리적인 단위, 파일 구조상의 데이터 항목 또는 데이터 필드에 해당한다
		3. **관계** : 개체 간의 관계 또는 속성 간의 논리적인 연결을 의미한다.
	3. **개념적 데이터 모델**
		* **현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다.**
		* 정보 모델이라고도 한다
		* E-R모델
	4. **논리적 데이터 모델**
		* 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
		* **관계 모델, 계층 모델, 네트워크 모델**
	5. **논리적 데이터 모델의 품질 검증**
		* 개체 품질 검증 항목
		* 속성 품질 검증 항목
			1. **다치 종속 속성**
			2. 주 식별자 및 비 식별자에 의존하는 속성
		* 관계 품질 검증 항목
		* 식별자 품질 검증 항목
		* 전반적인 품질 검증 항목
	6. **데이터 모델에 표시할 요소**
		1. **구조** : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
		2. **연산** : 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구
		3. **제약 조건** : 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

2. ### 이상/함수적 종속/정규화

	1. **이상**

		* **테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복으로 인해 테이블 조작 시 문제가 발생하는 현상을 의미한다.**

		1. **삽입 이상**
			* 테이블에 삽입할 때 의도아는 상관없이 원하지 않는 값들로 인해 삽입할 수 없게 되는 현상
		2. **삭제 이상**
			* 테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들로 함께 삭제되는,  **즉 연쇄 삭제가 발생하는 현상**
		3. **갱신 이상**
			* 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상이다.

	2. **함수적 종속**

		* **X -> Y 관계를 같은 속성에서**
		* Y에서 X를 결정자라 하고
		* Y를 종속자라 한다.

		1. **완전 함수적 종속**
			* **어떤 속성이 기본키에 대해 완전히 종속적일 때를 말합니다.**
		2. **부분 함수적 종속**
			* 기본키의 일부에 의해 속성이 결정될 때를 말합니다.

	3. **정규화**

		* **테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정이다**
		* **무손실 분해** : 원래대로 복원될 수 있는 분해
		* 목적은 가능한 중복을 제거하여 이상의 발생 가능성을 줄이는 것이다.

	4. **정규화 과정**

		* **제 1정규형**
			1. **모든 속성의 도메인 값이 원자 값으로만 이루어진 정규형**
		* **제 2정규형**
			1. **기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형이다.**
		* **제 3정규형**
			1. **기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형이다**
			2. **이행 함수적 종속** : A->B이고 B->C일때 A->C를 만족하는 관계
		* **BCNF**
			1. **모든 결정자가 후보키인 정규형이다**
		* **제 4정규형**
			1. **다중 값 종속이 A->B가 존재할 경우 모든R의 속성이 A에 함수적 종속 관계를 만족하는 정규형**
		* **제 5정규형**
			1. 모든 **조인 종속**이 R의 후보키를 통해서만 성립되는 정규형

3. ### 논리 데이터 모델의 물리 데이터 모델로 변환

  1. **테이블**

  	* 데이터를 저장하는 데이터베이스와 가장 기본적인 오브젝트이다.
  	* ***컬럼과 로우로 구성되며 컬럼에는 지정된 유형에 따라 데이터가 저장된다.**

  	1. **로우** : 튜플, 인스턴스, 어커런스라고도 한다.
  	2. **컬럼** :  각 속성 항목에 대한 값을 저장한다.
  	3. **기본키** : 후보키 중에서 선택한 주 키, **한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성**
  	4. **외래키** 
  		* 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
    		* 한 릴레이션에 속상 속성 A와 참조 릴레이션의 기본키가 B가 동일한 도메인 상에서 정의도었을 떄의 속성을 외래키라고 한다.

  2. **엔티티를 테이블로 변환**

  	* 정의된 엔티티를 물리 데이터 모델의 테이블로 변환하는 것이다.
  	* **테이블 목록 정의서** : 전체 테이블을 목록으로 요약 관리하는 문서로, 테이블 목록이라고도 한다.

  3. **슈퍼타입/서브타입을 테이블로 변환**

        1. **슈퍼 타입 기준 테이블 변환**

    	* 슈퍼타입 기준의 테이블 변환은 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것이다.
    	* **장점**
    		1. 데이터 엑세스 상대적 용이
    		2. 뷰를 이용하여 각각의 서브타입만을 액세스하거나 수정가능
    		3. 서브타입 구분이 없는 임의 집합에 대한 처리 용이
    		4. 여러 테이블 조인하지 않아도 되므로 수행속도가 빨라진다.
    		5. SQL문장 구성이 단순해진다.
    	* **단점**
    		1. 컬럼의 증가로 디스크 저장 공간이 증가
    		2. 처리마다 서브타입에 대한 구분이 필요한 경우가 많이 발생한다.
    		3. 인덱스 크기의 증가로 인덱스의 효율이 떨어진다.
    
    2. **서브타입 기준 테이블**
    
    	* 개별적인 테이블 만든다.
    	* **장점**
    		1. 각 서브타입 속성들의 선택 사양이 명확한 경우 유리
    		2. 서브타입 유형을 구분할 필요가 없다
    		3. 여러 개의 테이블로 통합하므로 테이블당 크기가 감소하여 **전체 스캔시 유리하다**
    	* **단점**
    		1. 수행 속도가 감소
    		2. 복잡한 처리를 하는 SQL의 통합이 어렵다.
    		3. 부분 범위에 대한 처리가 곤란해진다.
    		4. 여러 테이블을 통합한 뷰는 조회만 가능
    		5. UID 유지 관리가 어렵다.
    
    3. **개별타입 기준 테이블**
    
    	* 각각의 개별적인 테이블로 변환하는 것이다.
    	* **슈퍼타입과 서브타입 테이블들 사이에는 각각 1:1 관계가 형성된다.**
    	* 적용하는 경우
    		1. 전체 데이터에 대한 처리가 빈번한 경우
    		2. 대부분 독립적으로 발생하는 경우
    		3. 통합하는 테이블의 컬럼 수가 많은 경우
    		4. 서브타입의 컬럼 수가 많은 경우
    		5. 트랜잭션이 주로 슈퍼타입에서 발생하는 경우
    	* **장점**
    		1. 저장 공간이 상대적으로 적다
    		2. 슈퍼타입 또는 서브타입 각각이 테이블에 속한 정보만 조회하는 경우 문장 작성이 용이하다
    	* **단점**
    		1. 항상 조인이 발생하여 성능이 저하된다.
    
    4. **속성을 컬럼으로 변환**
    
      * 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환한다.
    
      1. **일반 속성 변환**
      	* 개발자 사용 간 의사소통을 위하여 가능한 한 표준화된 약어를 사용하여 일치
      	* 예약어 사용 피하고 가능한 짧게
      	* 샘플 데이터 작성으로 정합성을 검사
      2. **Primary UID를 기본키로 변환**
      	* 논리 데이터 모델에서의 Primary UID는 물리 데이터 모델의 기본키로 만든다.
      3. **주 식별자를 ( 관계의 UID Bar)를 기본키로 변환**
      	* 다른 엔티티와의 관계로 인해 생성된 주식별자는 물리 데이터 모델의 기본키로 만든다.
      4. **Secondary UID를 유니크키로 변환**
      	* 논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 모델에서 유니크키로 만든다.
    
    5. **관계를 외래키로 변환**
    
    	* 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 외래키로 변환한다.
    		1. 1 대 다
    		2. 다 대 다
    			* **릴레이션 A와 B 기본키를 모두 포함한 별도의 릴레이션으로 표현한다**
    			* **이를 교차 릴레이션 혹은 교차 엔티티라고 한다**
    			* **주로 계층관계를 나타낼때 사용한다.**
    
    6. **관리 목적의 테이블 컬럼 추가**
    
    	* 논리 데이터 모델에는 존재하지 않은 테이블이나 컬럼을 DB관리 혹은 데이터베이스를 이용하는 프로그래밍의 수행 속도를 향상시키기 위해 물리 데이터 모델에 추가할 수 있다.
    
    7. **데이터 타입 선택**
    
    	1. CHAR : 고정길이 문자열 최대 2000byte
    	2. VARCHAR2 : 가변길이 문자열 최대 4000byte
    	3. NUMBER : 38자릿수의 숫자 저장 가능
    	4. DATE

4. ### 반정규화

	1. **반정규화의 개념**

		* **시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위이다.**
		* **시스템 성능은 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다.**
		* **과도하면 성능저하**
		* 일관성 , 무결성을 우선으로 할지 아니면 성능과 단순화를 우선으로 할지를 결정해야한다.
		* 테이블 통합, 분할, 중복 테이블 추가, 중복 속성 추가 등이 있다.

	2. **테이블 통합**

		* **프로세스가 동일하게 자주 사용되는 경우**
		* 두개를 이용하여 항상 조회하는 경우
		* **통합시 고려사항**
			1. 레코드 증가로 인해 처리량 증가한다
			2. 입력, 수정, 삭제 규칙이 복잡해질 수 있다.
			3. 제약 조건을 설계하기 어렵다.

	3. **테이블 분할**

		1. **수평분할**

			* 레코를 기준으로 분할
			* 레코드별로 사용 빈도의 차이가 큰 경우

		2. **수직 분할**

			* 하나의 테이블에 속성이 너무 많을 경우
			* **갱신 위주의 분할** : 갱신이 자주 일어나는 속성들 분할
			* **자주 조회되는 속성 분할** : 테이블에서 자주 조회되는 속성이 극히 일부분 일 경우 분할
			* 크기가 큰 속성 분할
			* 보안 적용 속성 분할

			* **고려사항**
				1. 기본키의 유일성 관리가 어려워진다.
				2. 데이터양이 적거나 사용량이 적으면 필요한지 고민해봐야 된다.
				3. 수행속도 느려질 수 있다.
				4. 데이터 검색에 중점을 두어 테이블 분할 여부를 결정해야 한다.

	4. **중복 테이블 추가**

		* **여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저정된 테이블을 이용해야 하는 경우 추가하여 작업의 효율성 향상**
		* **추가하는 경우**
			1. 정규화로 인해 수행속도가 느려진 경우
			2. 많은 범위 데이터를 자주 처리해야 하는 경우
			3. 특정 범위의 데이터만 자주 처리해야 하는 경우
			4. 처리 범위를 줄이지 않고 수행속도를 개선할 수 없는 경우
		* **방법**
			1. 집계 테이블 추가
			2. 진행 테이블의 추가

	5. **중복 속성 추가**

		* **조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것이다.**
		* **추가하는 경우**
			1. 조인이 자주 발생
			2. 접근 경로가 복잡한 경우
			3. 엑세스의 조건 자주 사용하는 경우
			4. 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우
		* **고려사항**
			1. 테이블 중복과 속성의 중복을 고려
			2. 일관성 및 무결성에 유의
			3. SQL그룹 함수를 이용하여 처리가능해야 한다.
			4. 저장 공간의 지나친 낭비를 고려한다.

5. ### 인덱스 설계

	1. **인덱스의 개념**

		* **데이터 레코드를 빠르게 접근하기 위해서 <키 값, 포인터> 쌍으로 구성되는 데이터 구조이다.**
		* 인덱스는 데이터가 저장된 물리적 구조와 밀접한 관계가 있다.
		* 저장된 물리적 구조의 접근하는 방법을 제공한다
		* 파일의 레코드에 대한 엑세스를 빠르게 수행할 수 있다.
		* **인덱스가 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 확인하는 TABLE SCAN이 발생한다.**
		* **레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터드 인덱스라고한다**
		* **클러스터드 인덱스**
			1. 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
			2. 실제 데이터가 순서대로 저장되어 있어 검색하지 않아도 빠르게 찾기 가능
			3. 삽입, 삭제 발생시 순서를 유지하기 위해 재정렬
			4. 한 개의 릴레이션에 하나의 인덱스만 생성할 수 있다.
		* **넌클러스터드 인덱스**
			1. 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
			2. 데이터 검색을 위해 먼저 인덱스를 검색하여 실제 데이터의 위치를 확인해야 하므로 클러스터드 인덱스에 비해 검색 속도가 떨어진다.
			3. 한 개의 릴레이션에 여러 개의 인덱스를 만들 수 있습니다.

	2. **트리 기반 인덱스**

		* **블록들이 트리 구조를 이루고 있는 것**
		* 주로 B+트리 활용한다.

		1. **B 트리 인덱스**
			* 일반적으로 사용되는 인덱스 방식으로, 루트 노드에서 하위 노드로 키 값의 크기를 비교해 나가면서 단말 노드에서 찾고하는 데이터를 검색한다.
			* 키 값과 레코드를 가리키는 포인터들이 트리 노드에 오름차순으로 저장된다.
			* 모든 리프 노드는 같은 레벨에 있다.
		2. **B+ 트리 인덱스**
			* B+트리는 B트리의 변형으로 단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분한다.
			* 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 있는 경로로만 제공되며
			* 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킨다.
			* 인덱스 세트에 있는 모든 키 값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차처리가 가능한다.
    3. **비트맵 인덱스**
        * **비트맵 인덱스는 인덱스 컬럼의 데이터를 Bit 값인 0, 1로 변환하여 인덱스 키로 사용하는 방법이다**
        * 목적은 키 값을 포함하는 로우의 주소를 제공하는 것이다.
        * **분포도가 좋은 컬럼에 적합하며, 성능 향상 효과를 얻을 수 있다.**
        * 효율적인 논리 연산 가능
        * 다중 조건을 만족하는 튜플의 개수 계산에 적합하다.
        * 동일한 값이 반복되는 경우가 많아 압축 효율이 좋다. 
    4. **함수 기반 인덱스**
        * **함수 기반 인덱스는 컬럼의 값 대신 컬럼의 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것으로, B+ 트리 인덱스 또는 비트맵 인덱스 생성하여 사용한다.**
        * 함수 기반 인덱스는 데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하가 발생할 수 있다.
        * 사용된 함수가 사용자 정의 함수일 경우 시스템 함수보다 부하가 더 크다.
        * 함수 기반 인덱스는 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용된다.
        * **적용 가능 함수**
            1. 산술식,
            2. 사용자 정의
            3. SQL Function
            4. C callout등
    5. **비트맵 조인 인덱스**
        * 다수의 조인된 객체로 구성된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다르다.
        * 비트맵 조인 인덱스는 비트맵 인덱스와 물리적 구조가 동일하다.
    6. **도메인 인덱스**
        
        * 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스라고도 한다.**
    7. **인덱스 설계**
        * **설계할 때는 분명하게 드러난 컬럼에 대해 기본적인 인덱스를 먼저 지정한 후 개발 단계에서 필요한 인덱스의 설계를 반복적으로 진행해야 한다.**
        * **인덱스 설계 순서**
            1. 대상 테이블이나 컬럼 선정
            2. 효율성을 검토하여 인덱스 최적화를 수행한다.
            3. 인덱스 정의서를 작성한다.
    8. **인덱스 대상 테이블 선정 기준**
        1. **MULTI BLOCK READ** 수에 따라 판단
        2. 랜덤 액세스가 빈번한 테이블
        3. 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
        4. 다른 테이블과 순차적 조인이 발생되는 테이블
    9. **컬럼 선정 기준**
        1. **컬럼의 분포도가 10~15% 이내인 컬럼**
        2. 분포도 = (컬럼값의 평균 Row수 / 테이블의 총 Row수) x100
        3. 10~15% 이상이어도 부분 처리를 목적하는 컬럼
        4. 입출력 장표에서 조회, 출력 조건으로 사용되는 컬럼
        5. 자동생성되는 기본키와 유니크키 제약조건을 사용한 컬럼
        6. 가능한 수정이 빈번하지 않은 것
        7. order by, group by, union 이 빈번한 컬럼
        8. 분포도가 좁은 컬럼은 단독 인덱스로 생성
        9. 인덱스들이 자주 조합되어 사용되는 경우 하나의 결합 인덱스로 생성
    10. **인덱스 설계 시 고려사항**
        1. 새로추가 되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있다.
        2. 인덱스를 지나치게 많이 만들면 오버헤드 발생
        3. 넓은 범위를 인덱스로 처리하면 많은 오버헤드 발생
        4. 인덱스를 만들면 추가적인 저장 공간 필요
        5. 인덱스와 테이블 데이터의 저장 공간 분리되도록 설계
   
6. ### 뷰 설계

	1. **뷰의 개요**

		* 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
		* **뷰는 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다.**
		* 뷰는 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용된다.
		* 뷰는 조인문의 사용 최소화를 사용상의 편의성을 최대화한다.
		* 뷰를 생성하면 뷰 정의가 시스템 내에 저장되었다가 생성된 뷰 이름의 질의어에서 사용할 경우 질의어가 실행될 때 뷰에 정의된 기본 테이블로 대체되어 기본 테이블에 대해 실행한다.

	2. **뷰의 특징**

		1. 뷰는 기본 테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같다.
		2. 뷰는 가상 테이블이기 때문에 물리적으로 구현이되어 있지 않다
		3. 데이터의 논리적 독립성을 제공할 수 있다.
		4. 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.
		5. 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않은 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다.
		6. 기본 테이블의 **기본키를 포함한 속성 집합으로 뷰를 구성**해야만 삽입, 삭제, 갱신 가능
		7. 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.
		8. 뷰가 정의된 기본테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 된 다른 뷰도 자동 삭제된다.

	3. **장단점**

		* **장점**
			1. 논리적 데이터 독립성을 제공
			2. 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원
			3. 사용자의 데이터 관리를 간단하게 해준다
			4. 접근 제어를 통한 자동 보안이 제공
		* **단점**
			1. 독립적인 인덱스를 가질 수 없다.
			2. 뷰의 정의를 변경할 수 없다.
			3. 뷰로 구성된 내용에 대한 삽입, 삭제,갱신 연산에 제약이 따른다.

	4. **뷰 설계 순서**

		1. 대상 테이블 선정

			* 외부 시스템과 인터페이스에 관여하는 테이블

			* CRUD 매트릭스를 통해 여러 테이블이 동시에 자주 조인되어 접근되는 테이블

			* SQL문 작성 시 거의 모든 문장에서 **인라인 뷰 **방식으로 접근되는 테이블

				```sql
				select a.ban, a.name, a.exam
				from a, (select ban, avg(exam) avgs from student group by ban)b
				where a.ban= b.ban and a.exam >b.avgs;
				```

		2. 대상 컬럼을 선정

			* 보안을 유지해야 하는 컬럼은 주의 

		3. 정의서 작성

	5. **뷰 설계 시 고려사항**

		1. 테이블 구조가 단순화 될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성한다.
		2. 동일한 테이블이라도 업무에 따라 테이블을 이용하는 부분이 달라질 수 있으므로 사용할 데이터를 다양한 관점에서 제시해야한다
		3. 테이블 보안 유지를 고려하여 설계

7. ### 클러스터 설계

	1. **개요**
		* **데이터 저장시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법**
		* **클러스터링키**로 지정된 컬럼 값의 순서대로 저장되고, 여러 개의 테이블이 하나의 클러스터에 저장된다.
	2. **클러스터의 특징**
		* 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하시킨다.
		* **데이터 분포도가 넓을수록 유리하다**
		* 데이터 분포도가 넓은 테이블을 클러스터링 하면 저장 공간을 절약할 수 있습니다.
		* 클러스터링된 테이블은 클러스터링키 열을 공유하므로 저장 공간이 줄어든다.
		* 대용량 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋다
		* **처리범위가 넓다 -> 단일 테이블 클러스터링**
		* **조인이 많다 -> 다중 테이블 클러스터링**
	3. **클러스터 대상 테이블**
		1. 분포도가 넓은 테이블
		2. 대량의 범위를 자주 조회하는 테이블
		3. 입력, 수정, 삭제가 자주 발생하지 않는 테이블
		4. 자주 조인되어 사용되는 테이블
		5. order by, group by, union이 빈번한 테이블

8. ### 파티션 설계

	1. **파티션의 개요**
		* 파티션은 대용량의 테이블이나 인덱스를 작은 논리적인 단위인 파티션으로 나누는 것을 말한다.
		* 대용량 DB의 경우 중요한 몇개의 테이블에만 집중되어 데이터가 증가되므로 
		* 이런 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방히할 뿐만 아니라 데이터 관리도 쉬워진다.
		* 테이블이나 인덱스를 파티셔닝 하면 파티션키 또는 인덱스키에 따라 물리적으로 별도의 공간에 데이터가 저장된다.
		* 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션별로 수행된다.
	2. **장단점**
		* **장점**
			1. 데이터 접근시 액세스 범위 줄이기
			2. 디스크 성능 향상
			3. 백업 및 복구 속도 증가
			4. 가용성 향상
		* **단점**
			1. 하나의 테이블을 세분화하여 관리하므로 세심한 관리요구
			2. 테이블간 조인에 대한 비용이 증가
			3. 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능 저하
	3. **종류**
		1. **범위 분할**
			* 지정한 열의 값을 기준으로 분할한다.
		2. **해시분할**
			* 해시 함수 결과값으로 저장
			* 고르게 분산
			* 고객번호 주민번호 같은 데이터가 고른 컬럼에 효과적
		3. **조합분할**
			* 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할
			* 파티션이 너무 커서 관리가 힘들면 이렇게함
	4. **파티션키 선정 시 고려 사항**
		* 테이블 접근 유형에 따라
	5. **인덱스 파티션**
		* **인덱스 파티션은 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것이다.**
		* local : 테이블 파티션과 인덱스 파티션이 1:1대응
		* global : 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티셔닝
		* local이 global에 비해 데이터 관리가 쉽다.
		* Prefixed : 인덱스 파티션키와 인덱스 첫 컬럼이 같다.
		* Non-Prefixed  인덱스 파티션키와 인덱스 첫 번째 컬럼이 다르다.

9. ### 데이터베이스 용량 설계

	1. **용량 설계**
		* 데이터가 저장될 공간을 정의
		* 데이터양 인덱스 클러스터 등 차지하는 공간 등을 예측하여 반영
	2. **목적**
		* 용량을 정확히 산정하여 디스크의 저장 공간을  효과적으로 사용하고 확장성 및 가용성을 높인다.
		* 디스크 입출력 부하를 분산시킨다.
	3. **절차**
		1. 데이터 예상 건수, 로우 길이, 보존 기간, 증가율 등 기초 자료를 수집하여 용량을 분석한다.
		2. 분석된 자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트 별 용량을 산정한다.
		3. 테이블과 인덱스의 테이블스페이스 용량을 산정한다.
		4. 데이터베이스에 저장될 모든 데이터 용량과 데이터베이스 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량을 산정한다.
	4. 