### 정보처리기사

---

1. **소프트웨어 설계**
	1. 애플리케이션 설계
		1. [소프트웨어 아키텍처](#소프트웨어-아키텍처)
		2. [아키텍처 패턴](#아키텍처-패턴)
		3. [객체지향](#객체지향)
		4. [모듈](#모듈)
		5. [공통 모듈](#공통-모듈)
		6. [코드](#코드)
		7. [디자인 패턴](#디자인-패턴)

---



1. ### 소프트웨어 아키텍처

    1. **소프트웨어 아키텍처의 설계**
    
        * 소프트웨어의 골격이 되는 기본 구조
        * 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
        * 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
        * 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정
        * **아키텍처 패턴이란 여러 문제를 막기 위해 만들어둔 전형적인 해결 방식 또는 예제를 뜻합니다.**
    
    1. **모듈화**
    
        * 소프트웨어의 성능을 향상하거나 시스템의 수정 및 재사용 유지관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
        * 모듈의 크기와 개수는 반비례관계 개수와 통합 비용은 비례
        * **너무 작으면 통합비용이 너무 크면 개별 비용이 증가**
    
    1. **추상화**
    
        * 문제의 전체를 설계 후 세분화하여 구체좌하는 과정
        * 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어 여러 가지 요인들을 테스트할 수 있음
        * 최소 비용으로 실제 상황에 대처할 수 있고 시스템의 구조 및 구성을 대략적으로 파악 가능
        * **추상화 유형**
            1. 과정 : 전반적인 **흐름만 파악**
            2. 데이터 : **데이터의 세부사항은 정의하지 않고 **구조를 대표할 수 있는 표현으로 대체
            3. 제어 : **이벤트의 발생의 세부사항은 정의하지 않고 주로르 대표할 수 있는 표현으로 대체**
    
    2. **단계적 분해**
    
        * 문제를 상위 중요 개념으로부터 하위 개념으로 구체화하는 분할 기법
        * 추상화의 반복으로 세분화
    
    1. **정보 은닉**
        
        * 한 모듈 내부에 포함된 정보들을 감추어 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
        * 다른 모듈과 커뮤니케이션을 할 때는 필요한 정보만 인터페이스를 통해 주고 받음
        * 모듈을 독립적으로 수행하기 때문에 다른 모듈에 영향 x
        * 테스트 유지보수에 용이
    
    1. **소프트웨어 아키텍처의 품질 속성**
    
        * 소프트웨어 아키텍처가 **이해 관계자**들이 요구하는 수준의 품질을 유지하고 보장할 수 있게 설계되어있는지를 확인하기 위해 품질 요소들을 구체화시켜 놓은 것
        
        1. **시스템 측면**
            1. **성능 : 요청과 같은 이벤트 발생시 빠르게 처리**
            2. 보안 : **허용된 접근**만 처리하고 나머지 차단
            3. **가용성 : 장애 없이 정상 서비스 제공**
            4. **기능성 : 요구한 기능 구현**
            5. 사용성 : **명확하고 편리**하게 구현
            6. 변경 용이성 : **다른 HW, 플랫폼에도 동작**하도록 구현
            7. 확장성 : **시스템 확장**시 효과적으로 활용할수 잇돌고 구현
            8. 기타 속성 : 텍스트 용이성, 배치성, 안전성 등
        2. **비즈니스 측면**
            1. 시장 적시성 : 정해진 시간에 맞춰 프로그램 출시
            2. 비용과 혜택 : 비용투자로 유연성 높은 아키텍처를 만들지 결정 
            3. 예상 시스템 수명 : 시스템을 얼마나 사용할지 고려 길면 용이성, 확장성을 더 고려
            4. 기타 속성 : 목표 시장, 공개 일정, 기존 시스템과 통합 등
        3. **아키텍처 측면**
            1. 개념적 무결성 : 전체 시스템과 구성요소들 간 일관성 유지
            2. 정확성 완결성 : 요구사항을 위해 발생하는 제약사항들을 모두 충족
            3. 구축 가능성 : 모듈 단위로 구분된 시스템을 적절하게 분배하여 일정을 변경가능하게
            4. 기타 속성 : 변경성, 시험성, 적응성, 일치성, 대체성 등 
    
    4. **소프트웨어 아키텍처의 설계 과정**
    
        1. 설계 목표 설정 
            * 시스템의 개발 방향을 명확히 하기 위해 요구사항을 분석하여 목표 설계 설정
        2. 시스템 타입 결정
            * 시스템과 서브 시스템 타입 결정
            * **설계목표를 고려한 아키텍쳐 패턴** 결정
        3. 아키텍처 패턴 적용
            * 아키텍처 패턴을 참조하여 시스템의 **표준 아키텍처 설계**
        4. 서브시스템 구체화
            * 서브시스템의 기능 및 상호작용을 위한 동작과 인터페이스 정의
        5. 결론
            * 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지 등을 검토 

2. ### 아키텍처 패턴

	2. **아키텍처 패턴의 개요**

		* 아키텍처를 설계할 때 참조할 수 있는 **전형적인 해결 방식 또는 예제**
		* 시스템의 구조를 구성하기 위한 **기본적인 틀을 제공**
		* 서브시스템과 그 역할이 정의되어있어 서브시스템 사이 관계와 규칙, 지침 등이 포함되어 있음
		* 장점
			1. 개발 시간 단축
			2. 고품질 SW 생산 가능
			3. 검증된 구조로 안전성 보장
			4. 구조 개념이 있으면 유지보수 쉬움

	2. **레이어 패턴**

		* 시스템을 계층으로 구분하여 구성
		* 각각의 서비 시스템이 계층을 이룸
		* 상위는 하위에 대한 서비스 제공자가 되고 하위는 상위의 클라가 됨
		* **마주 하는 계층끼리만 상호작용 가능**
		* 특정 계층만을 교체해 시스템 개선 가능

	3. **클라이언트 - 서버 패턴**

		* **하나의 서버와 다수 클라 구성 가능**
		* 사용자는 클라로 서버에 요청을 보내고 서버가 답을 줌
		* **서버는 항상 대기상태**
		* 요청을 위한 동기화를 제외하고는 독립적이다.

	4. **파이프 - 필터 패턴**

		+ 데이터 스트림 절차의 각 단계를 필터 **컴포넌트 캡슐화**하여 파이프를 통해 데이터를 전송
		+ 필터 컴포넌트는 **재사용성이 좋고 추가가 쉬워 확장이 용이**
		+ **재배치**하여 다양한 라인 구축 가능
		+ 데이터 변환, 버퍼링, 동기화 등에 사용

	5. **모델 - 뷰 - 컨트롤러 패턴**

		+ 서브시스템을 3개의 부분으로 구조화
			1. 모델 : 서브시스템의 핵심 기능과 데이터 보관
			2. 뷰 : 사용자에게 정보 표시
			3. 컨트롤러 : 사용자로부터 받은 입력 처리
		+ 각 부분은 별도로 분리되어 있어 **서로 영향을 받지 않고 독립적인 개발 작업 수행**
		+ 여러 개의 뷰를 만들 수 있어 **한 개의 모델에 여러 개의 뷰를 필요로 하는 대화형 어플리케이션에 적합**

	6. **기타 패턴**

		1. Master slave

			* **마스터** 컴포넌트에서 **슬레이브로 작업**을 분할한 후 슬레이브에서 **처리된 결과물을 다시 돌려받는 방식**
			* **장애 허용 시스템**과 **병렬 컴퓨터 시스템**에 주로 활용

		2. Broker

			* 사용자가 원하는 서비스와 특성을 브로커에 요청하면 브로커가 요청에 맞는 컴포넌트 연결
			* 주로 **분산 환경 시스템**에 활용된다

		3. peer to peer

			* 피어를 하나의 컴포넌트로 간주해 **각 피어는 클라이언트도 가능하고 서버도 가능하다**
			* **전형적인 멀티스레드 방식**

		4. Event Bus

			* 소스가 특정 채널에 **이벤트 메시지를 발행**하면 해당 **채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식**

			1. 소스 : 이벤트 생성
			2. 리스너 : 이벤트 수행
			3. 채널 : 이벤트 통로
			4. 버스 : 채널들을 관리

		5. BlackBoard

			* 모든 컴포넌트들이 **공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능하여 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있음**
			* 해결책이 명확하지 않은 곳에서 사용
			* 음성인식, 차량 식별 등

		6. Interperter

			* 프로그램 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성
			* 특정 언어 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용 

		7. **순서**

			* **요구사항 분석 -> 시스템과 서브시스템 타입 결정 -> 기능과 인터페이스 정의 -> 표준 아키텍처 설계**

3. ### 객체지향

	1. **객체지향의 개요**
		* 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어 소프트웨어를 개발할 때 객체를 조립하여 작성할 수 있는 기법
		* 구조적 기법의 문제점을 해결하기 위해 사용
		* 소프트웨어의 재사용 및 확장이 용이하여 고품질 빠르게 개발 가능
		* 복잡한 구조를 단계적이고 계층적으로 표현
		* 멀티미디어 데이터 및 병렬 처리 지원
		* 구성 요소
			1. 객체
			2. 클래스
			3. 캡슐화
			4. 상속
			5. 다형성
	2. **객체**
		* 데이터와 데이터를 처리하는 함수를 묶어 **캡슐화**한 하나의 소프트웨어 모듈
		* 데이터
			1. 객체가 가지고 있는 정보
			2. 속성, 상태, 변수, 상수, 자료구조 라고도 함
		* 함수 
			1. 객체가 수행하는 기능으로 데이터를 처리하는 알고리즘
			2. 객체의 상태를 참조하거나 변경하는 수단으로 메소드, 서비스, 동작 연산이라고도 함
		* 객체의 특성
			1. 객체는 **독립적인 식별 가능한 이름**을 가지고 있다.
			2. 객체의 **상태는 시간에 따라 변함**
			3. 객체 간의 **상호 연관성에 의해 관계 형성**
			4. 객체가 반응할 수 있는 메시지의 집합을 행위라고 하며 객체는 행위의 특징을 나타낼수 있음
			5. 객체는 **일정한 기억 장소**를 가지고 있다
	3. **클래스**
		+ 공통된 속성과 연산을 갖는 객체의 집합을 객체 일반적인 타입을 의미 
		+ 객체들이 갖는 속성과 연산을 정의하고 있는 틀
		+ **인스턴스** : 클래스에 속한 각각의 객체
		+ **인스턴스화** : 클래스로부터 새로운 객체를 생성하는 것
		+ 슈퍼 클래스 : 특정 클래스의 부모 클래스
		+ 서브 클래스 : 특정 클래스의 자식 클래스
	4. **캡슐화**
		* 데이터와 함수를 하나로 묶은 것
		* 인터페이스를 제외한 세부 내용이 은폐되어 외부에서 접근이 제한적이기 때문에 외부에서 변경이 어렵다.
		* 재사용성이 높아지고 **객체 간의 결합도가 낮아진다.**
	5. **상속**
		* 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
		* 하위는 부모껄 다 정의 안해도 사용 가능
		* 하위는 상속받은걸 새로 수정하여 사용 가능
		* 객체와 클래스의 재사용성을 높이는 개념
		* **다중 상속** : 여러 클래스를 상속받는 것
	6. **다형성**
		* 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 클래스가 가지고 있는 고유한 특성으로 응답할 수 있는 능력
		* 객체들은 동일한 **메소드명**을 사용하여 같은 의미의 응답을 한다

4. ### 모듈

	1. **모듈의 개요**
		* 모듈화를 통해 분리된 시스템의 간 기능들
		* 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용
		* 단독으로 컴파일 후 사용 가능
		* 각 모듈의 기능은 독립적이고 하나의 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용 배제
		* 독립성이 높을수록 모듈을 수정해도 달느 모듈에 영향이 없어 오류가 발생해도 쉽게 해결 가능
		* 모듈의 독립성을 높이기 위해 **결합도는 약하게, 응집도는 강하게**해야 함
	2. **결합도 Coupling**
		* 모듈 간의 상호 의존도, 연관 관계
		* **결합도와 품질은 반비례**
		* 결합이 강하면 유지보수가 힘들다.
		* 종류
			1. Data
				* 모듈간 인터페이스가 자료 요소로만 구성될 때의 결합도
				* 모듈 호출시 변수, 인수를 넘겨주고 결과를 반환 받는 방식
				* **제일 좋은거**
			2. Stamp
				* 모듈간에 **자료구조**가 전달될 때
				* **두 모듈이 공통의 자료 구조를 조회하는 경우의 결합도**
				* **자료구조가 변경되면 조회하는 모듈도 영향을 받는다**
			3. Control
				* 다른 모듈의 내부의 논리적인 흐름을 제어하기 위해 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도
				* **권리 전도 현상** : 하위 모듈이 상위 모듈에게 신호를 보내 처리 명령을 내리는 경우 
			4. External
				* 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도
				* 참조되는 데이터의 범위를 각 모듈에서 제한
			5. Common
				* 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
				* 공통 데이터 영역의 내용을 변경 시 이를 사용하는 모든 모듈에 영향을 미쳐 독립성을 저하 시킨다.
			6. Content
				* 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
				* 다른 모듈의 내부로 제어가 이동하는 경우도 포함
				* **제일 안 좋음**
	3. **응집도 Cohesion**
		* 정보 은닉 개념을 확장한 것으로 모듈의 내부 요소들의 서로 관련되어 있는 정도
		* 모듈이 독립적인 기능으로 정의되어 있는 정도
		* **응집도와 품질은 비례**
		* 종류
			1. Functional
				* 모듈 내부의 모든 기능 요소들이 **단일 문제와 연관**되어 수행될 경우의 응집도
			2. Sequential
				* 모듈 내 하나의 활동으로부터 **나온 데이터를 그 다음 활동의 입력 데이터**로 사용할 경우의 응집도
			3. Communication
				* 동일한 입력과 출력을 사용하여 **서로 다른 기능을 수행하는 구성 요소**들이 모였을 경우의 응집도
			4. Procedural
				* 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그기능을 **순차적으로** 수행할 경우 응집도
			5. Temporal
				* **특정 시간**에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우
			6. Logical
				* 유사한 성격을 갖거나 특정 형태로 뷴류되는 처리 요소들로 하나의 모듈을 형성하는 경우
			7. Coincidental
				* 각 내부 구성요소들이 **서로 관련 없는 요소들로 ** 이루어진 경우
	4. **Fan In / Fan out**
		* **Fan In : 호출하는 모듈의 수**
		* **Fan Out : 호출되는 모듈의 수**

5. ### 공통 모듈

	1. **공통 모듈의 개요**
		* 여러 프로그램에서 **공통적으로 사용할 수 있는 모듈**
		* 자주 사용되는 계산식이나 매번 필요한 사용자 인증 같은 기능들이 공통 모듈로 구성될 수 있음
		* 공통 모듈의 명세 기법
			1. Correctness : 시스템에 필요하다는 걸 **정확히** 작성
			2. Clarity : 중의적 해석되지 않도록 **확하게 작성**
			3. Completeness : 필요한 모든걸 기술
			4. Consistency : **상호 충돌이 발생하지 않도록 작성**
			5. Traceablitiy : **시스템의 관계를 파악 가능하도록 작성 **
	2. **재사용**
		* 비용과 시간을 절약하기 위해 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 개발에 사용하기 적합하도록 최적화 시키는 작업
		* 재사용되는 대상은 외부 모듈과의 결합도는 낮고 응집도는 높아야 함
	3. **효과적인 모듈 설계 방안**
		* 결합도는 줄이고 응집도는 높여 독립성과 재사용성을 높임
		* 하나의 입구와 하나의 출구 가져야함
		* **모듈 제어 영역 안에서 그 모듈의 영향 영역을 유지시킨다.**
		* 인덱스 번호나 기능 코드들이 전반적인 처리 논리 구조에 예기치 못한 영향을 끼치지 않도록 모듈 인터페이스를 설계

6. ### 코드

	1. **코드의 개요**
		* 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고 특정 자료의 추출을 쉽게 하기 위해 사용하는 기호
		* 기능
			1. 식별
			2. 분류
			3. 배열
	2. **코드의 종류**
		1. **Sequence**
			* 일정 기준에 따라 최초의 자료부터 **일련번호를 부여하는 방법**
			* 1,2,3,4
		2. **Block**
			* 대상 항목에서 **공통적인 것을 블록으로 구분**하여 블록 내에 일련번호를 부여
			* 1001~1100 : 컴공, 1101~1200 : 기계과
		3. **Decimal**
			* 대상 항목을 **0~9까지의 10진 분할**하고 다시 각각에 대하여 **10진 분할을 반복**
			* 1000: 공대,  1100: 예대, 1200: 사과대
		4. **Group Classification**
			* 일정 기준에 따라 **대,중,소 분류**로 구분하고 그룹 안에서 일련번호 부여
			* 1-01-001 : 본사 , 2-01-001 : 지사
		5. **Mnemonic**
			*  항목의 명칭이나 **약호와 관계 있는 숫자, 문자, 기호**를 이용하여 코드 부여
			* TV-40 : 40인치 티비, L-15 : 15W 램프
		6. **Significant Digit**
			* 항목의 성질 **물리적인 수치**를 그대로 코드에 적용
			* 120-345-1500 : 두께X폭X길이인 강판
		7. **Combinde**
			*  하나의 코드로 수행하기 **어려울 경우 2개 이상의 코드 합쳐서 적용**
			* KE-114 : 대한한공 114기,  AC-354 : 에어캐나다 354기
	3. **코드 부여 체계**
		* 코드 만으로 개체의 용도와 적용 범위를 알 수 있도록 부여
		* 시스테므이 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 함
		* 코드의 자릿수와 구분자, 구조 등을 상세하게 명시

7. ### 디자인 패턴

	1. **디자인 패턴 개요**

		* 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할때 참조할 수 있는 **전형적인 해결 방식 또는 예제**
		* 개발 과정에 문제가 발생 시 **새로운 해결책을 구상하기보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더욱 효율적임**
		* 재사용할 수 있는 기본형 코드들이 포함되어 있음

	2. **Creational Pattern**

		* 객체의 생성과 참조 과정을 샘플화 하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 하여 프로그램의 유연성을 더해줌

		1. **Abstract Factory**
			* 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 **연관 의존하는 객체들의 그룹을 생성하여 추상적**으로 표현한다
			* **연관된 서브클래스를 묶어 한 번에 교체 가능**
		2. **Builder**
			* 작게 분리된 인스턴스를 **건축 하듯이 조립하여 객체 생성**
			* 객체의 생성과 표현 방법을 분리, 동일한 객체 생성에서도 **서로 다른 결과를 만들어 낼 수 있다.**
		3. **Factory**
			* **객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화한 패턴**
			* 상위 클래스에서 인터페이스만 정의하고 **실제 생성은 서브클래스가 담당**
		4. **Prototype**
			* 원본 객체를 **복제**하는 방법으로 객체 생성
			* **객체 생성의 비용이 큰 경우 사용**
		5. **Singleton**
			* 하나의 객체를 생성하면 생성된 객체를 어디서든 참조하지만 **여러 프로세스 동시 참조는 불가능**
			* 클래스 내에서 인스턴가 하나뿐임을 보장하고 **불필요한 메모리 낭비를 줄인다.**

	3. **Structural Patten**

		* 구조 패턴은 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴이다.
		* 구조 패턴은 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.

		1. **Adapter**
			* **호완성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환**해주는 패턴이다
			* **기존의 클래스를 이용**하고 싶지만 인터페이스가 **일치하지 않을 때 이용**
		2. **Bridge**
			* **구현부에서 추상층을 분리하여 서로가 독립적으로 확장**할 수 있도록 구성한 패턴
			* **기능**과 **구현 **두개의 별도 클래스 구현
		3. **Compoiste**
			* 여러 객체를 가진 **복합 객체**와 **단일 객체를 구분 없이 다루고자 할 때** 사용하는 패턴이다
			* 객체들을 트리 구조로 구성하여 디렉터리 안에 디럭터리가 있듯이 복합 객체 안에 포함되는 구조를 구현할 수 있다.
		4. **Decorator**
			* **객체 간의 결합을 통해 능동적으로 기능들을 확장**할 수 있는 패턴
			* 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현
			* **상속을 사용하지 않고도 객체를 동적으로 확장**
		5. **Facade**
			* 복잡한 서브 클래스들을 피해 **더 상위 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴**
			* 서브 클래스들 사이의 통합 인터페이스를 제공하는 **Wrapper 객체가 필요하다**
		6. **Flyweight**
			* 인스턴스를 가능한 공유해서 **메모리 절약**
			* 다수의 **유사 객체를 생성하거나 조작할 때 유용**
		7. **Proxy**
			* **접근이 어려운 객체**와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
			* **네트워크 연결**, 메모리의 대용량 객체로의 접근 등에 주로 이용한다.

	4. **Behavioral Pattern**

		* **행위 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법**을 정의하는 패턴으로 총 11개의 패턴이다.
		* **행위 패턴은 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와준다.**

		1. **Chain of Responsibility**

			* 요청을 처리하는 객체가 2개 이상이고 하나가 못하면 다음으로 넘기는 방식
			* 요청을 처리할 객체들이 **Chain으로 묶여** 있어 요청이 해결 될때까지 고리에 따라 책임을 넘김

		2. **Command**

			* **요청을 객체의 형태로 캡슐화**하여 재이용하거나 취소할 수 있도록 요청에 피룡한 정보를 저장하거나 로그를 남기는 패턴
			* 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화 한다.

		3. **Interperter**

			* 언어에 문법 표현을 정의하는 패턴
			* **SQL, 통신 프로토콜 같은걸 개발할때 사용**

		4. **Iterator**

			* 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
			* **내부 표현 방법의 노출없이 순차적인 접근 가능**
			* 다음노래 자동 재생

		5. **Mediator**

			* 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
			* **객체 사이의 의존성을 줄여 결합도 감소 가능**

		6. **Memento**

			* 특정 시점에서 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 말한다.
			* Ctrl + z와 같은 기능 

		7. **Observer**

			* **한 객체의 상태가 변화하면 객체에 상속되어 있는 다른객체들이 변화**
			* 주로 분산된 시스템이나 이벤트 생성 발생 수신 때 사용

		8. **State**

			* 객체의 상태에 따라 동일한 동작을 다르게 처리할 떄 사용
			* **객체 상태를 캡슐화하고 이를 참조하는 방식**

		9. **Strategy**

			* **동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의한 패턴**
			* 클라이언트는 **독립적으로 알고리즘을 사용할 수 있다**
			* **클라이언트의 영향없이 알고리즘의 변경 가능**

		10. **Template**

			* **상위 클래스에서 골격을 정의하고 하위에서 세부 처리를 구체화 하는 구조**
			* 유사한 서브 클래스르 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수에 용이

		11. **Vistor**

			* 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스를 구성하는 패턴이다.
			* **분리된 처리 기능은 각 클래스를 방문하여 수행한다.**

			